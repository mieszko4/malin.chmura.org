<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Kopalnia Diament√≥w - Idle Clicker</title>
<link rel="stylesheet" href="styles.css" />

</head>
<body>
<button id="btn-reset" aria-label="Resetuj stan gry">Reset</button>
<div id="app" role="main">
  <div id="player-diamonds" aria-live="polite" aria-atomic="true">üíé Diamenty: 0</div>
  <div id="team-efficiency" aria-live="polite" aria-atomic="true" style="text-align: center; margin: 10px 0; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; font-weight: bold;">
    üöÄ Wydajno≈õƒá dru≈ºyny: <span id="total-efficiency">0 d/s</span>
  </div>
  
  <!-- Kontener transportowy - sta≈Çy element nad korytarzami -->
  <div id="transport-container" class="transport-container" aria-label="System transportu diament√≥w">
    <!-- Platforma roz≈Çadunkowa po lewej stronie -->
    <div id="unloading-platform" class="unloading-platform">
      <div class="platform-icon">üöö</div>
      <div class="platform-label">Platforma</div>
      <div class="platform-diamonds">0</div>
    </div>
    
    <!-- Obszar kurier√≥w w ≈õrodku -->
    <div id="kurierzy-area" class="kurierzy-area">
      <!-- Kurierzy bƒôdƒÖ dodawani dynamicznie -->
    </div>
    
    <!-- Sejf po prawej stronie -->
    <div id="safe" class="safe">
      <div class="safe-icon">üè¶</div>
      <div class="safe-label">Sejf</div>
      <div class="safe-diamonds">0</div>
    </div>
  </div>
  
  <section id="team" aria-label="Dru≈ºyna bohater√≥w i korytarze" role="list"></section>
  <button id="btn-mine" aria-label="Rƒôczne kopanie diament√≥w">Kop</button>
  <section class="shop-container" aria-label="Sklep bohater√≥w">
    <div class="shop-title">Sklep bohater√≥w</div>
    <div class="shop-list" id="heroes-list" role="list"></div>
  </section>
  <section class="shop-container" aria-label="Sklep narzƒôdzi">
    <div class="shop-title">Sklep narzƒôdzi</div>
    <div class="shop-list" id="tools-list" role="list"></div>
  </section>
</div>
<div id="popup" role="dialog" aria-modal="true" aria-labelledby="popup-title" aria-describedby="popup-desc">
  <div id="popup-content" tabindex="0">
    <h3 id="popup-title"></h3>
    <div id="popup-desc"></div>
    <button id="popup-action" class="action-btn"></button>
    <button id="popup-close">Zamknij</button>
  </div>
</div>
<script>
(() => {
  "use strict";

  function formatNumber(n) {
    n = Number(n) || 0;
    if (n < 1000) {
      return Math.floor(n).toString();
    }
    const si = [
      { value: 1e12, symbol: "t" },
      { value: 1e9, symbol: "b" },
      { value: 1e6, symbol: "m" },
      { value: 1e3, symbol: "k" }
    ];
    for (const item of si) {
      if (n >= item.value) {
        const val = n / item.value;
        return val.toFixed(2) + item.symbol;
      }
    }
    return n.toString();
  }

  const defaultHeroesData = [
    { id: 1, name: "Ma≈Çy Kret", icon: "üê≠", mining: 1, speed: 1, strength: 1, cost: 10, level: 1, exp: 0, unloadTime: 1.5, spritePrefix: 'k', spriteNumber: 1 },
    { id: 2, name: "Prosty Kret", icon: "üêπ", mining: 2, speed: 1.05, strength: 1, cost: 20, level: 1, exp: 0, unloadTime: 1.2, spritePrefix: 'k', spriteNumber: 2 },
    { id: 3, name: "≈ölepy Kret", icon: "üêÅ", mining: 3, speed: 1.1, strength: 1, cost: 40, level: 1, exp: 0, unloadTime: 1, spritePrefix: 'k', spriteNumber: 3 }
  ];
  const defaultToolsData = [
    { id: 1, name: "≈Åopata +1", icon: "‚õèÔ∏è", bonus: 1, cost: 50 },
    { id: 2, name: "M≈Çotek +1", icon: "üî®", bonus: 2, cost: 120 },
    { id: 3, name: "≈örubokrƒôt", icon: "ü™õ", bonus: 3, cost: 250 }
  ];

  let heroesData = [];
  let toolsData = [];
  // playerDiamonds usuniƒôte - teraz u≈ºywamy safeDiamonds jako g≈Ç√≥wnego magazynu
  const maxTeamSize = 12;
  let corridors = []; // Bƒôdzie dynamicznie rozszerzane
  let team = []; // Bƒôdzie dynamicznie rozszerzane
  let miningBoostMultiplier = 1;
  let equippedTools = [];
  
  // System transportu diament√≥w w korytarzu 0
  let transportDiamonds = 0; // Diamenty na platformie roz≈Çadunkowej
  let safeDiamonds = 0; // Diamenty w sejfie
  let transportHeroState = "idle"; // idle, moving-to-platform, moving-to-safe, loading, unloading
  let transportHeroPosition = 0; // Pozycja miƒôdzy platformƒÖ (0) a sejfem (1)
  let transportHeroLoad = 0; // Ile diament√≥w niesie
  let transportHeroCapacity = 50; // Pojemno≈õƒá transportu
  
  // System wielu kurier√≥w
  let kurierzyData = [];
  let kurierzyTeam = [];
  let kurierzyPurchased = {}; // Obiekt zamiast boolean

  const playerDiamondsSpan = document.getElementById("player-diamonds");
  const teamContainer = document.getElementById("team");
  const btnMine = document.getElementById("btn-mine");
  const heroesList = document.getElementById("heroes-list");
  const toolsList = document.getElementById("tools-list");
  const btnReset = document.getElementById("btn-reset");
  const popup = document.getElementById("popup");
  const popupTitle = document.getElementById("popup-title");
  const popupDesc = document.getElementById("popup-desc");
  const popupAction = document.getElementById("popup-action");
  const popupClose = document.getElementById("popup-close");

  // Animacja diamentu wy≈ÇƒÖczona

  // Zapewnij kontekst pozycjonowania dla sprite'√≥w
  teamContainer.style.position = "relative";

  async function loadJSON(url, fallback) {
    try {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`B≈ÇƒÖd ≈Çadowania ${url}`);
      return await res.json();
    } catch (e) {
      console.warn(e.message);
      return fallback;
    }
  }

  let namesData = { przymiotniki: [], zdrobnienia_imion: [], poziomy: {} };

  async function loadNames() {
    try {
      const res = await fetch("names.json");
      if (!res.ok) throw new Error("B≈ÇƒÖd ≈Çadowania names.json");
      namesData = await res.json();
    } catch (e) {
      namesData = { przymiotniki: ["Zwinny"], zdrobnienia_imion: ["Krecik"], poziomy: {} };
    }
  }

  function generateHeroName() {
    const adj = namesData.przymiotniki;
    const im = namesData.zdrobnienia_imion;
    if (!adj.length || !im.length) return "Bezimienny Kret";
    const przym = adj[Math.floor(Math.random() * adj.length)];
    const name = im[Math.floor(Math.random() * im.length)];
    return `${przym} ${name}`;
  }

  function createHeroInstance(base) {
    // Je≈õli base ma ju≈º instanceName, zachowaj je
    return {
      ...JSON.parse(JSON.stringify(base)),
      instanceName: base.instanceName || generateHeroName(),
      currentLoad: 0,
      position: 0,
      _targetPosition: 0, // Dodane dla p≈Çynnego ruchu
      _currentPosition: 0, // Dodane dla p≈Çynnego ruchu
      state: "commuting",
      miningProgress: 0,
      unloadTimer: 0,
      justMined: 0,
      _emittedUnloadFx: false // flaga: sprite tylko raz na roz≈Çadunek
    };
  }

  function createWindziarzInstance(base) {
    return {
      ...JSON.parse(JSON.stringify(base)),
      id: base.id || `windziarz-${Date.now()}`, // DODAJ TO je≈õli nie ma id
      position: -0.5,
      target: 0,
      state: "idle", // idle, moving, loading, returning, unloading
      carried: 0,
      loadingTimer: 0,
      unloadingTimer: 0, // DODAJ TO!
      exp: base.exp || 0,
      level: base.level || 1,
      capacity: base.capacity || 1000,
      loadingspeed: base.loadingspeed || 50,
      _spriteAcc: 0,
      _spriteTimer: 0
    };
  }

  function createKurierInstance(kurierBase) {
    return {
      ...JSON.parse(JSON.stringify(kurierBase)),
      position: 0, // Pozycja miƒôdzy platformƒÖ (0) a sejfem (1)
      state: "idle", // idle, moving-to-platform, moving-to-safe, loading, unloading
      carried: 0,
      currentLoad: 0,
      lastLoadingTime: 0,
      lastUnloadingTime: 0,
      loadingTimer: 0, // Timer dla ≈Çadowania
      unloadingTimer: 0, // Timer dla roz≈Çadunku
      progress: 0, // Postƒôp ruchu (0-1)
      target: "platform", // Cel ruchu: "platform" lub "safe"
      direction: "left", // Kierunek ruchu: "left" lub "right"
      capacity: kurierBase.capacity || 1000, // Pojemno≈õƒá kuriera
      speed: kurierBase.speed || 1.0, // Prƒôdko≈õƒá kuriera
      loadingspeed: kurierBase.loadingspeed || 50 // Szybko≈õƒá ≈Çadowania
    };
  }

  /**
   * Asynchronicznie pobiera i wycina bitmapƒô bohatera z arkusza sprit√≥w.
   *
   * @param {string} prefix Prefiks nazwy pliku (np. "k").
   * @param {number} heroNumber Numer bohatera (liczony od 1).
   * @returns {Promise<ImageBitmap|null>} Obietnica, kt√≥ra zwraca obiekt ImageBitmap
   * lub null, je≈õli wystƒÖpi≈Ç b≈ÇƒÖd
   * (np. z≈Çy numer, brak pliku).
   */
  async function getHeroBitmap(prefix, heroNumber) {
    // --- 1. Walidacja danych wej≈õciowych ---
    if (!prefix || typeof prefix !== 'string' || typeof heroNumber !== 'number' || heroNumber <= 0) {
      console.error("B≈Çƒôdne parametry wej≈õciowe.");
      return null;
    }

    // --- 2. Obliczenia pliku i pozycji sprita ---
    const SPRITES_PER_ROW = 5;
    const SPRITES_PER_COLUMN = 4;
    const SPRITES_PER_FILE = SPRITES_PER_ROW * SPRITES_PER_COLUMN; // 20 sprit√≥w na plik
    const SPRITE_SIZE = 128; // Rozmiar pojedynczego sprita w px

    // Oblicz, w kt√≥rym pliku znajduje siƒô bohater
    // Np. bohater 1-20 -> plik 1; bohater 21-40 -> plik 2
    const fileNumber = Math.ceil(heroNumber / SPRITES_PER_FILE);
    const imagePath = `images/${prefix}${fileNumber}.png`;

    // Oblicz pozycjƒô (indeks) bohatera w jego pliku (od 0 do 19)
    const indexInFile = (heroNumber - 1) % SPRITES_PER_FILE;

    // Oblicz wsp√≥≈Çrzƒôdne (x, y) sprita w siatce na arkuszu
    const sx = (indexInFile % SPRITES_PER_ROW) * SPRITE_SIZE;
    const sy = Math.floor(indexInFile / SPRITES_PER_ROW) * SPRITE_SIZE;

    // --- 3. Wczytanie obrazu i wyciƒôcie bitmapy ---
    try {
      // Stw√≥rz nowy obiekt obrazu w pamiƒôci
      const image = new Image();
      image.src = imagePath;

      // Poczekaj na za≈Çadowanie obrazu. Je≈õli ≈õcie≈ºka jest z≈Ça, .onerror odrzuci Promise.
      await image.decode(); // Nowocze≈õniejsza i bardziej niezawodna alternatywa dla image.onload

      // Wytnij odpowiedni fragment z wczytanego obrazu i stw√≥rz z niego bitmapƒô
      // To podej≈õcie jest wydajniejsze ni≈º rysowanie na dodatkowym canvasie.
      const bitmap = await createImageBitmap(image, sx, sy, SPRITE_SIZE, SPRITE_SIZE);

      return bitmap;
    } catch (error) {
      // B≈ÇƒÖd wystƒÖpi, je≈õli plik obrazu nie zostanie znaleziony (b≈ÇƒÖd 404) lub jest uszkodzony.
      console.error(`Nie uda≈Ço siƒô wczytaƒá pliku: ${imagePath}`, error);
      return null;
    }
  }

  function updateDiamondsDisplay() {
    playerDiamondsSpan.textContent = `üíé Diamenty: ${formatNumber(safeDiamonds)}`;
    checkElevatorEnabled();
  }
  
  function updateTeamEfficiency() {
    const totalEfficiencyEl = document.getElementById("total-efficiency");
    if (!totalEfficiencyEl) return;
    
    let totalEfficiency = 0;
    let activeMiners = 0;
    
    for (let i = 0; i < team.length; i++) {
      const hero = team[i];
      if (hero && hero.state !== "idle") {
        const efficiency = calculateMinerEfficiency(hero);
        totalEfficiency += efficiency.totalEfficiency;
        activeMiners++;
      }
    }
    
    totalEfficiencyEl.textContent = formatEfficiency(totalEfficiency);
    
    // Dodaj informacjƒô o liczbie aktywnych kopaczy
    const teamEfficiencyEl = document.getElementById("team-efficiency");
    if (teamEfficiencyEl && activeMiners > 0) {
      teamEfficiencyEl.innerHTML = `üöÄ Wydajno≈õƒá dru≈ºyny: <span id="total-efficiency">${formatEfficiency(totalEfficiency)}</span> (${activeMiners} aktywnych)`;
    }
  }

  // --- Diamond transfer animation framework ---
  const DIAMOND_SPRITE_MAX = 30; // Zwiƒôkszamy limit, bo animacje sƒÖ teraz l≈ºejsze
  let _activeDiamondSprites = 0;

  // spawn n sprites (capped) from startRect to endRect; doesn't affect scroll (position:fixed)
  function spawnDiamondSprites(startRect, endRect, n, durationOverride, onDiamondReach) {
    if (!startRect || !endRect || n <= 0) return;
    
    const toSpawn = Math.min(Math.round(n), DIAMOND_SPRITE_MAX - _activeDiamondSprites);
    if (toSpawn <= 0) return;

    const diamondsPerSprite = n / toSpawn;
    const totalDuration = (typeof durationOverride === 'number' && durationOverride > 0) ? durationOverride : 700;
    const flyTime = 700; // Sta≈Çy czas lotu pojedynczego diamentu w ms.

    // Usuniƒôte op√≥≈∫nienie startu - diamenty startujƒÖ od razu
    for (let k = 0; k < toSpawn; k++) {
      _activeDiamondSprites++;
      const el = document.createElement('div');
      el.className = 'diamond-sprite';
      el.textContent = 'üíé';
      
      const sx = startRect.left + startRect.width / 2;
      const sy = startRect.top + startRect.height / 2;
      const ex = endRect.left + endRect.width / 2;
      const ey = endRect.top + endRect.height / 2;

      el.style.position = 'fixed';
      el.style.left = sx + 'px';
      el.style.top = sy + 'px';
      el.style.zIndex = '14000';
      el.style.pointerEvents = 'none';

      el.style.setProperty('--dx', `${ex - sx}px`);
      el.style.setProperty('--dy', `${ey - sy}px`);
      
      el.style.animationDuration = `${flyTime}ms`;
      
      // Usuniƒôte op√≥≈∫nienie - diamenty startujƒÖ natychmiast
      // el.style.animationDelay = `${delay}ms`;

      document.body.appendChild(el);

      el.addEventListener('animationend', () => {
        el.remove();
        _activeDiamondSprites = Math.max(0, _activeDiamondSprites - 1);
        if (typeof onDiamondReach === 'function') {
          onDiamondReach(diamondsPerSprite);
        }
      });
    }
  }

  // helper: spawn sprites given corridor index by locating hero (round) and bucket bar elements in DOM
  function animateTransferInCorridor(corridorIndex, amount, durationMs) {
    try {
      const corridorEl = teamContainer.querySelector(`[data-corridor-index="${corridorIndex}"]`);
      if (!corridorEl) return;
      // use the round hero position as the start (reliable visual) and the bucket bar as the end
      const heroPosEl = corridorEl.querySelector('.hero-position');
      const bucketBarEl = corridorEl.querySelector('.bucket .bucket-bar');
      // fall back to previous elements if these are missing
      const heroEl = heroPosEl || corridorEl.querySelector('.hero-info .hero-icon');
      const bucketEl = bucketBarEl || corridorEl.querySelector('.bucket .bucket-icon') || corridorEl.querySelector('.bucket');
      if (!heroEl || !bucketEl) return;
      const heroRect = heroEl.getBoundingClientRect();
      const bucketRect = bucketEl.getBoundingClientRect();
      console.debug('animateTransferInCorridor', { corridorIndex, amount, durationMs, heroRect, bucketRect, heroEl, bucketEl });
      
      const corridor = corridors[corridorIndex];
      const onDiamondReach = (value) => {
        if (corridor) {
          const cap = corridor.bucketCapacity || 100;
          const space = Math.max(0, cap - (corridor.bucketAmount || 0));
          const transfer = Math.min(value, space);
          corridor.bucketAmount = (corridor.bucketAmount || 0) + transfer;
        }
      };
      spawnDiamondSprites(heroRect, bucketRect, amount, durationMs, onDiamondReach);
    } catch (e) { console.warn('animateTransfer err', e); }
  }
  // --- end animation framework ---

  function renderTeam() {
    teamContainer.innerHTML = "";
    for (let i = 0; i < corridors.length; i++) {
      // Pomi≈Ñ korytarz 0 - elementy transportowe sƒÖ w sta≈Çym kontenerze
      if (i === 0) continue;
      
      const corridor = corridors[i];
      const hero = team[i];
      const maxWallHP = corridor.wallHP + 2000;
      
      // Oblicz aktualnƒÖ wydajno≈õƒá dla aktywnego kopacza
      let currentEfficiency = 0;
      if (hero && hero.state !== "idle") {
        const efficiency = calculateMinerEfficiency(hero);
        currentEfficiency = efficiency.totalEfficiency;
      }

      const corridorEl = document.createElement("section");
      corridorEl.className = "corridor";
      corridorEl.dataset.corridorIndex = i;
      corridorEl.setAttribute("role", "listitem");
      corridorEl.setAttribute("aria-label", hero ? `Korytarz z bohaterem ${hero.name}` : "Wolny korytarz");
      corridorEl.style.position = "relative";



      // Przycisk burzenia korytarza (dla wszystkich korytarzy > 0)
      const destroyBtn = document.createElement('button');
      destroyBtn.textContent = 'üí•';
      destroyBtn.title = 'Zburz korytarz';
      destroyBtn.style.position = 'absolute';
      destroyBtn.style.top = '2px';
      destroyBtn.style.right = '5px';
      destroyBtn.style.zIndex = '10';
      destroyBtn.style.background = 'none';
      destroyBtn.style.border = 'none';
      destroyBtn.style.fontSize = '1.2rem';
      destroyBtn.style.cursor = 'pointer';
      destroyBtn.style.padding = '0';
      destroyBtn.onclick = (e) => {
        e.stopPropagation();
        destroyCorridor(i);
      };
      corridorEl.appendChild(destroyBtn);

           
      const heroInfo = document.createElement("div");
      heroInfo.className = "hero-info";
      if (hero) {
        // Dodaj klasƒô poziomu do hero-info
        const heroLevel = Math.min(10, hero.level || 1);
        heroInfo.classList.add(`hero-level-${heroLevel}`);
        
        heroInfo.style.cursor = "pointer";
        
        // Po≈ÇƒÖcz obie funkcjonalno≈õci w jeden onclick
        heroInfo.onclick = (e) => {
          e.stopPropagation();
          const isExpanded = heroInfo.classList.contains('expanded');
          
          // Zamknij wszystkie inne rozwiniƒôte panele
          document.querySelectorAll('.hero-info.expanded').forEach(el => {
            if (el !== heroInfo) {
              el.classList.remove('expanded');
            }
          });
          
          // Prze≈ÇƒÖcz stan bie≈ºƒÖcego panelu
          if (isExpanded) {
            heroInfo.classList.remove('expanded');
          } else {
            heroInfo.classList.add('expanded');
          }
          
          // Poka≈º popup z informacjami o bohaterze
          showHeroPopup(hero, i);
        };

        // Dodaj obwolutƒô
        const heroFrame = document.createElement('div');
        heroFrame.className = `hero-frame hero-level-${Math.min(10, hero.level)}`;

        const icon = document.createElement("div");
        icon.className = "hero-icon";

        if (typeof hero.spriteNumber === 'number') {
          icon.textContent = hero.icon; // Fallback na czas ≈Çadowania
          (async () => {
            const bitmap = await getHeroBitmap('k', hero.spriteNumber);
            if (bitmap && icon.isConnected) {
              const canvas = document.createElement('canvas');
              canvas.style.width = "100%";
              canvas.style.height = "100%";
              canvas.style.objectFit = "cover";
              const ctx = canvas.getContext('2d');
              ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
              icon.innerHTML = ''; // Wyczy≈õƒá fallback
              icon.appendChild(canvas);
            }
          })();
        } else if (hero.image) {
          const img = document.createElement("img");
          img.src = `images/${hero.image}`;
          img.alt = hero.name;
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "cover";
          img.onerror = () => {
            img.remove();
            icon.textContent = hero.icon;
          };
          icon.appendChild(img);
        } else {
          icon.textContent = hero.icon;
        }

        const nameContainer = document.createElement("div");
        nameContainer.className = "hero-name-container";
        
        const heroInstanceName = document.createElement("div");
        heroInstanceName.className = "hero-instance-name";
        
        // Dodaj nazwƒô i etykietƒô poziomu
        const levelName = namesData.poziomy?.[heroLevel]?.nazwa || `Poziom ${heroLevel}`;
        heroInstanceName.innerHTML = `
          ${hero.instanceName}
          <span class="hero-level-badge">${levelName}</span>
        `;
        nameContainer.appendChild(heroInstanceName);
        
        // Dodaj nazwƒô poziomu pomiƒôdzy nazwƒÖ a typem
        const heroLevelName = document.createElement("div");
        heroLevelName.className = "hero-level-name";
        heroLevelName.textContent = levelName;
        nameContainer.appendChild(heroLevelName);
        
        // Debug usuniƒôty - spowalnia≈Ç renderowanie

        const heroClassName = document.createElement("div");
        heroClassName.className = "hero-class-name";
        heroClassName.textContent = hero.name;
        nameContainer.appendChild(heroClassName);
        
        // Dodaj szczeg√≥≈Çowe informacje
        const heroDetails = document.createElement("div");
        heroDetails.className = "hero-details";
        
        // Oblicz wydajno≈õƒá kopacza
        const efficiency = calculateMinerEfficiency(hero);
        
        heroDetails.innerHTML = `
          <div class="hero-stat">
            <span class="hero-stat-label">Poziom:</span>
            <span class="hero-stat-value">${hero.level || 1}</span>
          </div>
          <div class="hero-stat">
            <span class="hero-stat-label">Do≈õwiadczenie:</span>
            <span class="hero-stat-value">${hero.exp || 0}/100</span>
          </div>
          <div class="hero-stat">
            <span class="hero-stat-label">Si≈Ça kopania:</span>
            <span class="hero-stat-value">${hero.mining || 1}</span>
          </div>
          <div class="hero-stat">
            <span class="hero-stat-label">Prƒôdko≈õƒá:</span>
            <span class="hero-stat-value">${(hero.speed || 1).toFixed(2)}</span>
          </div>
          <div class="hero-stat">
            <span class="hero-stat-label">Si≈Ça:</span>
            <span class="hero-stat-value">${hero.strength || 1}</span>
          </div>
          <div class="hero-stat efficiency-stat">
            <span class="hero-stat-label">Wydajno≈õƒá:</span>
            <span class="hero-stat-value efficiency-value">${formatEfficiency(efficiency.totalEfficiency)}</span>
          </div>
        `;
        nameContainer.appendChild(heroDetails);
        
        heroInfo.appendChild(icon);
        heroInfo.appendChild(nameContainer);
        heroInfo.appendChild(heroFrame);
      } else {
        // Korytarz zero - bez tekst√≥w
        // Usuniƒôte: heroInfo.textContent = "(wolny korytarz)";
        // Usuniƒôte: heroInfo.style.justifyContent = "center";
        // Usuniƒôte: heroInfo.style.color = "#999";
        
        // Pozostaw pusty korytarz bez tekst√≥w
      }
      corridorEl.appendChild(heroInfo);

      if (i > 0) {
        // wiadro na diamenty miƒôdzy bohaterem a korytarzem
        const bucketEl = document.createElement('div');
        bucketEl.className = 'bucket';

        // Dodaj klasƒô "full" gdy wiadro jest pe≈Çne
        if ((corridor.bucketAmount || 0) >= (corridor.bucketCapacity || 100)) {
          bucketEl.classList.add('full');
        }

        const bIcon = document.createElement('div'); 
        bIcon.className = 'bucket-icon'; 
        bIcon.textContent = 'ü™£'; // Ikona wiadra

        const bCap = document.createElement('div'); 
        bCap.className = 'bucket-cap'; 
        bCap.textContent = `${formatNumber(corridor.bucketAmount || 0)}/${formatNumber(corridor.bucketCapacity || 100)}`;

        const bBar = document.createElement('div'); 
        bBar.className = 'bucket-bar';
        const bFill = document.createElement('div'); 
        bFill.className = 'bucket-fill';
        const fillPct = Math.round(((corridor.bucketAmount || 0) / (corridor.bucketCapacity || 1)) * 100);
        bFill.style.width = `${fillPct}%`;
        bBar.appendChild(bFill);

        bucketEl.appendChild(bIcon);
        bucketEl.appendChild(bBar);
        bucketEl.appendChild(bCap);
        // tooltip + lepsze zachowanie klikniƒôcia
        bucketEl.title = 'Opr√≥≈ºnij wiadro (klik)';
        bucketEl.style.padding = '4px 6px';
        // upewnij siƒô, ≈ºe ikona nie blokuje klikniƒôcia
        bIcon.style.pointerEvents = 'none';
        bucketEl.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          const amt = corridor.bucketAmount || 0;
          if (amt <= 0) return;
          transportDiamonds += amt;
          corridor.bucketAmount = 0;
          updatePlatformCounter(); // Aktualizuj licznik platformy
          checkElevatorEnabled(); // Sprawd≈∫ czy winda powinna siƒô pojawiƒá
          saveGame();
          renderTeam();
        });
        corridorEl.appendChild(bucketEl);
              // Prawdziwy korytarz z ≈õcianƒÖ do kopania
        const wall = document.createElement("div");
        wall.className = "wall";
      const wallFill = document.createElement("div");
      wallFill.className = "wall-fill";
      // renderowanie przesuwajƒÖcej siƒô ≈õciany opartej na remainingDiamonds
      const maxD = corridor.maxDiamonds || 100;
      const remD = Math.max(0, Math.min(maxD, corridor.remainingDiamonds ?? maxD));
      const leftRatio = (corridor.wallStart || 0.1) + (1 - remD / maxD) * (1 - (corridor.wallStart || 0.1));
      const leftPct = (leftRatio * 100).toFixed(3);
      const widthPct = Math.max(0, ((1 - leftRatio) * 100).toFixed(3));
      wallFill.style.position = 'absolute';
      wallFill.style.left = leftPct + '%';
      wallFill.style.width = widthPct + '%';
      // etykieta pokazujƒÖca pozosta≈Çe diamenty - umieszczona wewnƒÖtrz niebieskiej czƒô≈õci (.wall-fill)
      const wallLabel = document.createElement('div');
      wallLabel.className = 'wall-label';
      wallLabel.textContent = `${formatNumber(remD)}/${formatNumber(maxD)}`;
      // ustawienie wewnƒÖtrz .wall-fill, wyr√≥wnane do prawej krawƒôdzi fill (ma≈Çy offset)
      wallLabel.style.right = '6px';
      wallLabel.style.left = 'auto';
      wallLabel.style.transform = 'translateY(-50%)';
      wallLabel.style.pointerEvents = 'none';
      wallFill.appendChild(wallLabel);
      wall.appendChild(wallFill);

      if (hero) {
        const heroPos = document.createElement("div");
        heroPos.className = "hero-position";
        heroPos.style.overflow = "hidden";
        heroPos.style.display = "flex";
        heroPos.style.alignItems = "center";
        heroPos.style.justifyContent = "center";
        heroPos.style.fontSize = "1rem";

        const icon = document.createElement("div");
        icon.textContent = hero.icon;
        icon.style.userSelect = "none";
        icon.style.transform = "scale(1.5)";
        icon.style.lineHeight = "1";
        icon.style.pointerEvents = "none";

        // kolory dla poszczeg√≥lnych faz
        const stateColors = { commuting: '#ffd166', mining: '#06d6a0', transporting: '#118ab2', unloading: '#ef476f', idle: '#9ca3af' };
        const stateBorders = { commuting: '#b58300', mining: '#0aa372', transporting: '#095a80', unloading: '#c11237', idle: '#6b7280' };
        const bg = stateColors[hero.state] || '#ffffff';
        const bd = stateBorders[hero.state] || '#0c80a6';
        heroPos.style.background = bg;
        heroPos.style.borderColor = bd;
        // kontrast dla ikony (≈º√≥≈Çty -> ciemny, pozosta≈Çe -> bia≈Çy)
        icon.style.color = (hero.state === 'commuting' || hero.state === 'idle') ? '#121212' : '#ffffff';

        heroPos.appendChild(icon);

        if (hero.state === "unloading" || hero.state === "idle") {
          // idle i unloading stojƒÖ na poczƒÖtku kopalni
          heroPos.style.left = "0%";
          heroPos.classList.add("unloading");
        } else {
          heroPos.classList.remove("unloading");
          let progressRatio = 0;
          if (hero.state === "commuting") progressRatio = Math.min(1, hero.position / 100);
          else if (hero.state === "mining") progressRatio = leftRatio; // podczas kopania stoi przy ≈õcianie
          else if (hero.state === "transporting") progressRatio = Math.min(1, hero.position / 100);
          heroPos.style.left = `${progressRatio * 100}%`;
        }

        wall.appendChild(heroPos);
      }
      corridorEl.appendChild(wall);
      }

      // Pasek postƒôpu dla wszystkich korytarzy
      const progressBarContainer = document.createElement("div");
      progressBarContainer.className = "progress-container";
      corridorEl.appendChild(progressBarContainer);

      const progressBarFill = document.createElement("div");
      progressBarFill.className = "progress-fill";
      progressBarFill.style.width = "0%";
      progressBarContainer.appendChild(progressBarFill);
      
      // Dodaj wska≈∫nik wydajno≈õci dla aktywnego kopacza
      if (hero && currentEfficiency > 0) {
        const efficiencyIndicator = document.createElement("div");
        efficiencyIndicator.className = "efficiency-indicator";
        efficiencyIndicator.innerHTML = `
          <span class="efficiency-label">Wydajno≈õƒá:</span>
          <span class="efficiency-rate">${formatEfficiency(currentEfficiency)}</span>
        `;
        efficiencyIndicator.style.position = "absolute";
        efficiencyIndicator.style.bottom = "5px";
        efficiencyIndicator.style.right = "5px";
        efficiencyIndicator.style.background = "rgba(0,0,0,0.8)";
        efficiencyIndicator.style.color = "#fff";
        efficiencyIndicator.style.padding = "4px 8px";
        efficiencyIndicator.style.borderRadius = "12px";
        efficiencyIndicator.style.fontSize = "0.8rem";
        efficiencyIndicator.style.fontWeight = "bold";
        efficiencyIndicator.style.zIndex = "10";
        corridorEl.appendChild(efficiencyIndicator);
      }

      if (hero && hero.state === "mining") {
        // u≈ºywamy currentLoad/strength aby pasek postƒôpu by≈Ç p≈Çynny
        const percent = Math.min(100, ((hero.currentLoad || 0) / (hero.strength || 1)) * 100);
        progressBarFill.style.width = `${percent}%`;
      }

      teamContainer.appendChild(corridorEl);
    }
    
    // Aktualizuj wydajno≈õƒá dru≈ºyny po renderowaniu
    updateTeamEfficiency();
    
    renderElevator();
  }

  function renderElevator() {
    let elevatorEl = document.getElementById("elevator");
    const shouldShowElevator = elevatorEnabled || windziarzTeam.length > 0;
    const appEl = document.getElementById("app");
    
    if (!elevatorEl) {
      elevatorEl = document.createElement("div");
      elevatorEl.id = "elevator";
      elevatorEl.style.position = "absolute";
      elevatorEl.style.width = "48px";
      elevatorEl.style.background = "linear-gradient(to bottom, #444 80%, #222 100%)";
      elevatorEl.style.borderRadius = "18px";
      elevatorEl.style.border = "2px solid #666";
      elevatorEl.style.display = shouldShowElevator ? "flex" : "none";
      elevatorEl.style.flexDirection = "column";
      elevatorEl.style.alignItems = "center";
      elevatorEl.style.justifyContent = "flex-start";
      elevatorEl.style.zIndex = "9000";
      elevatorEl.style.boxShadow = "2px 0 8px #000a";
      appEl.insertBefore(elevatorEl, document.getElementById("team"));
      
      // Dodaj pionowy pasek postƒôpu
      const progressBar = document.createElement("div");
      progressBar.className = "elevator-progress-bar";
      progressBar.id = "elevator-progress-bar";
      
      const progressFill = document.createElement("div");
      progressFill.className = "elevator-progress-fill";
      progressFill.id = "elevator-progress-fill";
      
      progressBar.appendChild(progressFill);
      elevatorEl.appendChild(progressBar);
    }
    
    // layout and visibility each call
    appEl.classList.toggle("with-elevator", shouldShowElevator);
    elevatorEl.style.display = shouldShowElevator ? "flex" : "none";
    elevatorEl.style.left = "8px";
    elevatorEl.style.top = teamContainer.offsetTop + "px";
    elevatorEl.style.height = teamContainer.offsetHeight + "px";
    
    if (shouldShowElevator) {
      // Aktualizuj pionowy pasek postƒôpu
      updateElevatorProgress();
      
      windziarzTeam.forEach((wz) => {
        let wzNode = document.getElementById(`windziarz-${wz.id}`);
        if (!wzNode) {
          elevatorEl.innerHTML = ''; // Wyczy≈õƒá starych windziarzy przy tworzeniu nowego
          
          // Dodaj pionowy pasek postƒôpu ponownie
          const progressBar = document.createElement("div");
          progressBar.className = "elevator-progress-bar";
          progressBar.id = "elevator-progress-bar";
          
          const progressFill = document.createElement("div");
          progressFill.className = "elevator-progress-fill";
          progressFill.id = "elevator-progress-fill";
          
          progressBar.appendChild(progressFill);
          elevatorEl.appendChild(progressBar);
          
          wzNode = document.createElement("div");
          wzNode.id = `windziarz-${wz.id}`;
          wzNode.className = "windziarz-pos";
          wzNode.style.margin = "8px 0";
          wzNode.style.fontSize = "2rem";
          wzNode.style.position = "absolute";
          wzNode.style.left = "50%";
          wzNode.style.transform = "translateX(-50%)";
          wzNode.style.cursor = "pointer";
          wzNode.onclick = () => showWindziarzPopup(wz);

          const wzIcon = document.createElement("div");
          wzIcon.className = "wz-icon";

          if (wz.image) {
            const img = document.createElement("img");
            img.src = `images/${wz.image}`;
            img.alt = wz.name;
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "cover";
            img.onerror = () => {
              img.remove();
              wzIcon.textContent = wz.icon;
            };
            wzIcon.appendChild(img);
          } else {
            wzIcon.textContent = wz.icon;
          }
          wzNode.appendChild(wzIcon);

          // Dodaj ko≈Çowy pasek postƒôpu
          const progressRing = document.createElement("div");
          progressRing.className = "windziarz-progress-ring";
          progressRing.id = `windziarz-progress-${wz.id}`;
          wzNode.appendChild(progressRing);

          const loadingBar = document.createElement("div");
          loadingBar.className = "loading-bar";
          const loadingFill = document.createElement("div");
          loadingFill.className = "loading-fill";
          loadingBar.appendChild(loadingFill);
          wzNode.appendChild(loadingBar);
          elevatorEl.appendChild(wzNode);
        }

        // Aktualizuj pozycjƒô i pasek ≈Çadowania
        // Oblicz pozycjƒô na podstawie rzeczywistych wysoko≈õci korytarzy
        let totalHeight = 0;
        let targetHeight = 0;
        
        if (wz.position <= 0) {
          // Windziarz na g√≥rze (sejf)
          targetHeight = 0;
        } else {
          // Windziarz w korytarzu - oblicz wysoko≈õƒá do tego korytarza
          for (let i = 0; i < Math.min(wz.position, corridors.length); i++) {
            const corridorEl = teamContainer.querySelector(`[data-corridor-index="${i}"]`);
            if (corridorEl) {
              totalHeight += corridorEl.offsetHeight;
            }
          }
          targetHeight = totalHeight;
        }
        
        wzNode.style.top = targetHeight + 12 + "px";
        
        // Aktualizuj ko≈Çowy pasek postƒôpu
        updateWindziarzProgress(wz);
        
        const loadingBar = wzNode.querySelector('.loading-bar');
        const loadingFill = wzNode.querySelector('.loading-fill');
        if (wz.carried > 0) {
          const fillPercentage = (wz.carried / (wz.capacity || 1000)) * 100;
          loadingFill.style.width = `${fillPercentage}%`;
          loadingBar.style.display = 'block';
        } else {
          loadingBar.style.display = 'none';
        }
      });
    } else {
      elevatorEl.innerHTML = "";
    }
  }

  // Nowa funkcja do aktualizacji pionowego paska postƒôpu w szybie
  function updateElevatorProgress() {
    if (windziarzTeam.length === 0) return;
    
    const progressFill = document.getElementById("elevator-progress-fill");
    if (!progressFill) return;
    
    // Znajd≈∫ najwy≈ºszƒÖ pozycjƒô windziarza
    let maxPosition = 0;
    windziarzTeam.forEach(wz => {
      if (wz.position > maxPosition) {
        maxPosition = wz.position;
      }
    });
    
    // Oblicz procent wype≈Çnienia na podstawie rzeczywistych wysoko≈õci
    let totalHeight = 0;
    if (maxPosition > 0) {
      for (let i = 0; i < Math.min(maxPosition, corridors.length); i++) {
        const corridorEl = teamContainer.querySelector(`[data-corridor-index="${i}"]`);
        if (corridorEl) {
          totalHeight += corridorEl.offsetHeight;
        }
      }
    }
    
    const fillPercentage = Math.min(100, (totalHeight / teamContainer.offsetHeight) * 100);
    
    progressFill.style.height = `${fillPercentage}%`;
    
    // Dodaj klasƒô active gdy windziarz siƒô porusza
    if (maxPosition > 0) {
      progressFill.classList.add('active');
    } else {
      progressFill.classList.remove('active');
    }
  }

  function showHeroPopup(hero, corridorIndex = null) {
    const isUpgrade = corridorIndex !== null;
    const heroData = isUpgrade ? hero : heroesData.find(h => h.id === hero.id);
    if (!heroData) return;

    const cost = isUpgrade ? (heroData.cost || hero.cost) : heroData.cost;
    
    // Oblicz wydajno≈õƒá kopacza
    const efficiency = calculateMinerEfficiency(heroData);

    popupTitle.textContent = heroData.name + (isUpgrade ? ` (Poziom ${heroData.level})` : '');
    popupDesc.innerHTML = `
      <div class="stat">Si≈Ça kopania: <b>${heroData.mining}</b></div>
      <div class="stat">Prƒôdko≈õƒá: <b>${heroData.speed.toFixed(2)}</b></div>
      <div class="stat">Si≈Ça: <b>${heroData.strength}</b></div>
      ${isUpgrade ? `<div class="stat">Do≈õwiadczenie: <b>${heroData.exp}</b></div>` : ''}
      <div class="stat">Czas roz≈Çadunku: <b>${(heroData.unloadTime || (5 / heroData.strength)).toFixed(2)}s</b></div>
      <div class="stat efficiency-stat">
        <span class="stat-label">Wydajno≈õƒá:</span>
        <span class="stat-value">${formatEfficiency(efficiency.totalEfficiency)}</span>
      </div>
      <div class="stat">
        <span class="stat-label">Czas cyklu:</span>
        <span class="stat-value">${efficiency.cycleTime.toFixed(2)}s</span>
      </div>
      <div class="stat">
        <span class="stat-label">Szczeg√≥≈Çy cyklu:</span>
        <span class="stat-value">
          üö∂ ${efficiency.travelTimeToWall.toFixed(2)}s do ≈õciany<br>
          ‚õèÔ∏è ${efficiency.fillTime.toFixed(2)}s kopanie<br>
          üö∂ ${efficiency.travelTimeBack.toFixed(2)}s powr√≥t<br>
          üì¶ ${efficiency.unloadTime.toFixed(2)}s roz≈Çadunek
        </span>
      </div>
      <hr>
      <div class="stat">Koszt ${isUpgrade ? 'ulepszenia' : 'zakupu'}: <b>üíé ${formatNumber(cost)}</b></div>
    `;
    popupAction.style.display = "block";
    popupAction.textContent = isUpgrade ? "Ulepsz" : "Kup";

    popupAction.onclick = () => {
      if (safeDiamonds < cost) {
        alert("Za ma≈Ço diament√≥w.");
        return;
      }
      safeDiamonds -= cost;

      if (isUpgrade) {
        // Logika ulepszania istniejƒÖcego bohatera
        const heroToUpgrade = team[corridorIndex];
        heroToUpgrade.level++;
        heroToUpgrade.mining = Math.floor(heroToUpgrade.mining * 1.1 + 1);
        heroToUpgrade.strength = Math.floor(heroToUpgrade.strength * 1.1 + 1);
        heroToUpgrade.speed *= 1.03;
        heroToUpgrade.cost = Math.floor(cost * 1.15); // Koszt ulepszenia ro≈õnie dla tej instancji
      } else {
        // Logika kupowania nowego bohatera
        let freeSlotIndex = -1;
        for (let i = 1; i < team.length; i++) {
          if (team[i] === null) {
            freeSlotIndex = i;
            break;
          }
        }
        
        if (freeSlotIndex === -1) {
          // Je≈õli nie ma wolnego miejsca, dodaj nowy korytarz
          if (corridors.length >= maxTeamSize) {
            alert("OsiƒÖgniƒôto maksymalnƒÖ liczbƒô korytarzy.");
            safeDiamonds += cost; // Zwr√≥ƒá diamenty
            return;
          }

          // Dodaj nowy korytarz
          if (addNewCorridor()) {
            freeSlotIndex = team.length - 1;
          } else {
            alert("Nie uda≈Ço siƒô dodaƒá nowego korytarza.");
            safeDiamonds += cost;
            return;
          }
        }
        
        const newHeroInstance = createHeroInstance(heroData);
        team[freeSlotIndex] = newHeroInstance;
        
        // Ustaw pojemno≈õƒá wiadra na 10x Strength nowego bohatera
        const newBucketCapacity = (newHeroInstance.strength || 1) * 10;
        corridors[freeSlotIndex].bucketCapacity = newBucketCapacity;
        
        // Zwiƒôksz koszt zakupu w sklepie dla tego typu bohatera
        heroData.cost = Math.floor(cost * 1.15);
      }

      updateDiamondsDisplay();
      saveGame();
      popup.style.display = "none";
      renderHeroesShop();
      renderTeam();
    };

    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function createNewCorridor() {
    return {
      wallHP: 10000 + Math.floor(Math.random() * 90000),
      maxDiamonds: getRandomDiamonds(),
      remainingDiamonds: getRandomDiamonds(),
      wallStart: 0.1,
      bucketCapacity: 100, // Domy≈õlna pojemno≈õƒá dla pustych korytarzy
      bucketAmount: 0
    };
  }

  function addNewCorridor() {
    if (corridors.length >= maxTeamSize) {
      console.warn("OsiƒÖgniƒôto maksymalnƒÖ liczbƒô korytarzy");
      return false;
    }

    const newCorridor = createNewCorridor();
    corridors.push(newCorridor);
    team.push(null); // Dodaj pusty slot dla kopacza

    console.log(`Dodano nowy korytarz ${corridors.length}. ≈ÅƒÖczna liczba: ${corridors.length}`);
    return true;
  }

  function initializeFirstCorridor() {
    // Zawsze zaczynamy z jednym korytarzem (korytarz 0)
    if (corridors.length === 0) {
      addNewCorridor();
    }
    // Upewnij siƒô, ≈ºe mamy korytarz 1 dla domy≈õlnego kopacza
    if (corridors.length === 1) {
      addNewCorridor();
    }
  }

  function updateTransportSystem(dt) {
    // Debug logi usuniƒôte - powodowa≈Çy zawieszenia
    
    // Sprawd≈∫ czy sƒÖ kupione kurierzy (debug usuniƒôty)
    
    if (kurierzyTeam.length === 0) {
        return;
    }
    
    // Aktualizuj kurier√≥w
    kurierzyTeam.forEach((kurier, index) => {
        updateKurier(kurier, dt);
    });
    
    // ... existing code ...
  }

  function updateKurier(kurier, dt) {
    const kurierEl = document.getElementById(`kurier-${kurier.id}`);
    if (!kurierEl) {
        console.log(`Kurier ${kurier.id}: Nie znaleziono elementu DOM`);
        return;
    }

    // Logika stan√≥w kuriera
    
    switch (kurier.state) {
        case "idle":
            // Sprawd≈∫ czy windziarz akurat roz≈Çadowuje diamenty
            const windziarzUnloading = windziarzTeam.some(wz => wz.state === "unloading" && wz.unloadingTimer > 0);
            const kurierHasSpace = (kurier.carried || 0) < (kurier.capacity || 1000);
            

            
            if (transportDiamonds > 0 && !windziarzUnloading) {
                // Brak windziarza roz≈ÇadowujƒÖcego - kurier mo≈ºe ≈Çadowaƒá
                kurier.state = "loading";
            } else if (transportDiamonds > 0 && windziarzUnloading && kurierHasSpace) {
                // Windziarz roz≈Çadowuje i kurier ma miejsce - kurier czeka na pe≈Çny roz≈Çadunek
            } else if (transportDiamonds > 0 && windziarzUnloading && !kurierHasSpace) {
                // Windziarz roz≈Çadowuje ale kurier jest pe≈Çny - mo≈ºe ≈Çadowaƒá mimo roz≈Çadunku
                kurier.state = "loading";
            } else if (transportDiamonds <= 0) {
                // Brak diament√≥w na platformie
            } else {
                // Inne przypadki
            }
            break;
            
        case "moving-to-platform":
            kurier.state = "moving";
            kurier.target = "platform";
            kurier.direction = "left";
            kurier.progress = 0;
            break;
            
        case "moving":
            // Ruch do sejfu (od platformy do sejfu)
            const moveSpeed = (kurier.speed || 1.0) * dt * 1.0; // Pe≈Çna prƒôdko≈õƒá
            kurier.progress += moveSpeed;
            
            if (kurier.progress >= 1.0) {
                kurier.progress = 1.0;
                kurier.state = "unloading";
            }
            break;
            
        case "returning":
            // Ruch do platformy (od sejfu do platformy) - progress 1.0 ‚Üí 0.0
            const returnSpeed = (kurier.speed || 1.0) * dt * 1.0; // Pe≈Çna prƒôdko≈õƒá
            kurier.progress -= returnSpeed; // Zmniejsz progress (1.0 ‚Üí 0.0)
            
            if (kurier.progress <= 0.0) {
                kurier.progress = 0.0;
                kurier.state = "loading";
            }
            break;
            
        case "loading":
            // Je≈õli timer nie jest ustawiony, ustaw go
            if (kurier.loadingTimer <= 0) {
                const loadAmount = Math.min(transportDiamonds, kurier.capacity || 1000);
                if (loadAmount > 0) {
                    // Ustaw timer na czas ≈Çadowania
                    const loadingSpeed = kurier.loadingspeed || 50;
                    kurier.loadingTimer = loadAmount / loadingSpeed;
                } else {
                    // Brak diament√≥w na platformie - wr√≥ƒá do stanu idle
                    kurier.state = "idle";
                    kurier.progress = 0;
                }
            }
            
            // Odejmuj czas od timera
            if (kurier.loadingTimer > 0) {
                kurier.loadingTimer -= dt;
            }
            
            // Gdy timer dobiegnie ko≈Ñca, zako≈Ñcz ≈Çadowanie
            if (kurier.loadingTimer <= 0) {
                const loadAmount = Math.min(transportDiamonds, kurier.capacity || 1000);
                if (loadAmount > 0) {
                    transportDiamonds -= loadAmount;
                    kurier.carried = loadAmount;
                    
                    // Przejd≈∫ do ruchu do sejfu
                    kurier.state = "moving";
                    kurier.target = "safe";
                    kurier.direction = "right";
                    kurier.progress = 0;
                    kurier._moveStartTime = Date.now();
                    updatePlatformCounter();
                }
            }
            break;
            
        case "unloading":
            // Je≈õli timer nie jest ustawiony, ustaw go
            if (kurier.unloadingTimer <= 0) {
                if (kurier.carried > 0) {
                    // Ustaw timer na czas roz≈Çadunku
                    const unloadingSpeed = kurier.loadingspeed || 50;
                    kurier.unloadingTimer = kurier.carried / unloadingSpeed;
                } else {
                    // Kurier nie ma diament√≥w do roz≈Çadowania - wr√≥ƒá do platformy
                    kurier.state = "returning";
                    kurier.target = "platform";
                    kurier.direction = "left";
                    kurier.progress = 1.0; // Zaczyna od prawej krawƒôdzi
                }
            }
            
            // Odejmuj czas od timera
            if (kurier.unloadingTimer > 0) {
                kurier.unloadingTimer -= dt;
            }
            
            // Gdy timer dobiegnie ko≈Ñca, zako≈Ñcz roz≈Çadunek
            if (kurier.unloadingTimer <= 0) {
                if (kurier.carried > 0) {
                    safeDiamonds += kurier.carried;
                    kurier.carried = 0;
                    
                    // Przejd≈∫ do fazy returning (powr√≥t do platformy)
                    kurier.state = "returning";
                    kurier.target = "platform";
                    kurier.direction = "left";
                    kurier.progress = 1.0; // Zaczyna od prawej krawƒôdzi (1.0)
                    updateSafeDisplay(); // Od≈õwie≈º wy≈õwietlanie sejfu
                    saveGame(); // Zapisz stan gry
                }
            }
            break;
            
        default:
            break;
    }
    
        // Pozycjonowanie jest teraz w renderTransportContainer() - usuniƒôte stƒÖd
}

  function destroyCorridor(index) {
    if (index <= 0 || index >= corridors.length) return;
    if (confirm('Czy na pewno chcesz zburzyƒá ten korytarz? Bohater i diamenty w wiadrze zostanƒÖ utracone!')) {
      team.splice(index, 1);
      corridors.splice(index, 1);

      team.push(null);
      corridors.push(createNewCorridor());

      saveGame();
      renderTeam();
    }
  }

  function showWindziarzPopup(wz) {
    popupTitle.textContent = wz.name;
    popupDesc.innerHTML = `
      <div class="stat">Poziom: <b>${wz.level}</b></div>
      <div class="stat">Do≈õwiadczenie: <b>${wz.exp}</b></div>
      <div class="stat">Prƒôdko≈õƒá: <b>${(wz.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Si≈Ça: <b>${wz.strength}</b></div>
      <div class="stat">Pojemno≈õƒá: <b>${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Za≈Çadunek: <b>${formatNumber(wz.carried)} / ${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Szybko≈õƒá ≈Çadowania: <b>${wz.loadingspeed} d/s</b></div>
    `;
    popupAction.style.display = "none";
    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function showWindziarzPurchasePopup(wz) {
    popupTitle.textContent = wz.name;
    popupDesc.innerHTML = `
      <div class="stat">Prƒôdko≈õƒá: <b>${(wz.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Pojemno≈õƒá: <b>${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Szybko≈õƒá ≈Çadowania: <b>${wz.loadingspeed} d/s</b></div>
      <hr>
      <div class="stat">Koszt: <b>üíé ${formatNumber(wz.cost)}</b></div>
    `;
    popupAction.style.display = "block";
    popupAction.textContent = "Kup";

    popupAction.onclick = () => {
      if (safeDiamonds < wz.cost) {
        alert("Za ma≈Ço diament√≥w na zakup windziarza.");
        return;
      }
      
      safeDiamonds -= wz.cost;
      windziarzTeam = [createWindziarzInstance(wz)];
      windziarzPurchased = true;
      updateDiamondsDisplay();
      saveGame();
      popup.style.display = "none";
      renderWindziarzeShop();
      renderElevator();
    };

    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function showKurierPurchasePopup(kurierData) {
    popupTitle.textContent = kurierData.name;
    popupDesc.innerHTML = `
      <div class="stat">Prƒôdko≈õƒá: <b>${(kurierData.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Pojemno≈õƒá: <b>${formatNumber(kurierData.capacity)}</b></div>
      <div class="stat">Szybko≈õƒá ≈Çadowania: <b>${kurierData.loadingspeed} d/s</b></div>
      <hr>
      <div class="stat">Koszt: <b>üíé ${formatNumber(kurierData.cost)}</b></div>
    `;
    popupAction.style.display = "block";
    popupAction.textContent = "Kup";

    popupAction.onclick = () => {
      console.log("=== ROZPOCZƒòCIE ZAKUPU KURIERA ===");
      console.log("safeDiamonds:", safeDiamonds, "koszt:", kurierData.cost);
      
      if (safeDiamonds < kurierData.cost) {
        alert("Za ma≈Ço diament√≥w na zakup kuriera.");
        return;
      }
      
      console.log("Sprawdzenie koszt√≥w - OK");
      safeDiamonds -= kurierData.cost;
      kurierzyPurchased[kurierData.id] = (kurierzyPurchased[kurierData.id] || 0) + 1;
      
      console.log("Tworzƒô instancjƒô kuriera...");
      // Nowy kurier zastƒôpuje starego (tak samo jak windziarz)
      const newKurier = createKurierInstance(kurierData);
      console.log("Utworzona instancja kuriera:", newKurier);
      
      kurierzyTeam = [newKurier]; // ZastƒÖp starego kuriera nowym
      console.log(`Kurier ${kurierData.id} zastƒÖpi≈Ç poprzedniego:`, newKurier);
      console.log("kurierzyTeam po zastƒÖpieniu:", kurierzyTeam);
      
      try {
        console.log("Wywo≈Çujƒô updateDiamondsDisplay()...");
        updateDiamondsDisplay();
        
        console.log("Wywo≈Çujƒô renderKurierzyShop()...");
        renderKurierzyShop();
        
        console.log("Wywo≈Çujƒô renderTeam()...");
        // Przerenderuj korytarz 0 ≈ºeby pokazaƒá nowego kuriera
        renderTeam();
        
        console.log("Kurier zakupiony pomy≈õlnie, zamykam popup");
        
        // Zamknij popup
        popup.style.display = "none";
        
        console.log("Wywo≈Çujƒô saveGame()...");
        saveGame();
        
        console.log("=== ZAKUP KURIERA ZAKO≈ÉCZONY ===");
      } catch (error) {
        console.error("B≈ÇƒÖd podczas zakupu kuriera:", error);
        console.error("Stack trace:", error.stack);
        // Mimo b≈Çƒôdu zamknij popup
        popup.style.display = "none";
      }
    };

    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function showKurierPopup(kurier) {
    popupTitle.textContent = kurier.name;
    popupDesc.innerHTML = `
      <div class="stat">Poziom: <b>${kurier.level}</b></div>
      <div class="stat">Do≈õwiadczenie: <b>${kurier.exp}</b></div>
      <div class="stat">Prƒôdko≈õƒá: <b>${(kurier.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Pojemno≈õƒá: <b>${formatNumber(kurier.capacity)}</b></div>
      <div class="stat">Za≈Çadunek: <b>${formatNumber(kurier.currentLoad)} / ${formatNumber(kurier.capacity)}</b></div>
      <div class="stat">Szybko≈õƒá ≈Çadowania: <b>${kurier.loadingspeed} d/s</b></div>
    `;
    popupAction.style.display = "none";
    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  popupClose.onclick = () => {
    popup.style.display = "none";
  };
  popup.addEventListener("click", e => {
    if (e.target === popup) popup.style.display = "none";
  });

  function renderHeroesShop() {
    heroesList.innerHTML = "";
    for (const heroBase of heroesData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = heroBase.name;

      const icon = document.createElement("div");
      icon.className = "shop-icon";
      icon.textContent = heroBase.icon;
      item.appendChild(icon);

      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = heroBase.name;
      item.appendChild(name);

      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `üíé ${formatNumber(heroBase.cost)}`;
      item.appendChild(cost);

      item.onclick = () => {
        // Wywo≈Çujemy popup bez indeksu, co oznacza "kupowanie"
        showHeroPopup(heroBase);
      };

      heroesList.appendChild(item);
    }
  }

  function renderToolsShop() {
    toolsList.innerHTML = "";
    for (const tool of toolsData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = tool.name;

      const icon = document.createElement("div");
      icon.className = "shop-icon";
      icon.textContent = tool.icon || "üß∞";
      item.appendChild(icon);

      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = tool.name;
      item.appendChild(name);

      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `üíé ${formatNumber(tool.cost)}`;
      item.appendChild(cost);

      item.onclick = () => {
        if (safeDiamonds < tool.cost) {
          alert("Za ma≈Ço diament√≥w na zakup.");
          return;
        }
        if (equippedTools.find(t => t.name === tool.name)) {
          alert("Ju≈º masz to narzƒôdzie.");
          return;
        }
        safeDiamonds -= tool.cost;
        updateDiamondsDisplay();
        equippedTools.push({ ...tool, durability: 100 });
        updateMiningBoost();
        renderToolsShop();
        saveGame();
      };

      toolsList.appendChild(item);
    }
  }

  function gameLoopStep(dt) {
    let diamondsGained = 0;
    for (let i = 0; i < team.length; i++) {
      const hero = team[i];
      if (!hero) continue;
      const corridor = corridors[i];
      const DIST = 100;
      
      // P≈Çynniejszy ruch - zwiƒôkszona prƒôdko≈õƒá i lepsza interpolacja
      const speed = hero.speed * dt * 80; // Zwiƒôkszona z 50 do 80 dla p≈Çynniejszego ruchu
      
      // Dodaj p≈ÇynnƒÖ interpolacjƒô pozycji
      if (!hero._targetPosition) hero._targetPosition = hero.position || 0;
      if (!hero._currentPosition) hero._currentPosition = hero.position || 0;

      switch (hero.state) {
        case "commuting":
          // P≈Çynny ruch do ≈õciany
          hero._targetPosition = Math.min(DIST, hero._targetPosition + speed);
          
          // Interpolacja pozycji dla p≈Çynnego ruchu
          const moveProgress = Math.min(1, dt * 10); // Szybko≈õƒá interpolacji
          hero._currentPosition += (hero._targetPosition - hero._currentPosition) * moveProgress;
          hero.position = hero._currentPosition;
          
          // oblicz pozycjƒô ≈õciany (w tej samej skali co hero.position [0..100])
          const maxD2 = corridor.maxDiamonds || 100;
          const remD2 = Math.max(0, Math.min(maxD2, corridor.remainingDiamonds ?? maxD2));
          const leftRatio2 = (corridor.wallStart || 0.1) + (1 - remD2 / maxD2) * (1 - (corridor.wallStart || 0.1));
          const targetPos = leftRatio2 * DIST;
          
          if (hero._targetPosition >= targetPos) {
            hero.state = "mining";
            hero.miningProgress = 0;
            hero.currentLoad = 0;
            hero.justMined = 0;
            // ustaw pozycjƒô bohatera dok≈Çadnie przy ≈õcianie
            hero.position = targetPos;
            hero._targetPosition = targetPos;
            hero._currentPosition = targetPos;
          }
          break;
          
        case "mining":
          // odejmuj ilo≈õƒá wykopanƒÖ w tej klatce (p≈Çynnie)
          const minedFloat = hero.mining * miningBoostMultiplier * dt;
          // inkrementuj wewnƒôtrzny licznik (opcjonalnie - do innych mechanik)
          hero.miningProgress = (hero.miningProgress || 0) + minedFloat;
          const actualMined = Math.min(minedFloat, corridor.remainingDiamonds || 0);
          corridor.remainingDiamonds = Math.max(0, (corridor.remainingDiamonds || 0) - actualMined);
          hero.currentLoad += actualMined;
          hero.justMined = actualMined;

          const durabilityLoss = actualMined * 0.1;
          equippedTools.forEach(t => (t.durability = Math.max(0, t.durability - durabilityLoss)));
          equippedTools = equippedTools.filter(t => t.durability > 0);
          renderToolsShop();

          if (hero.currentLoad >= hero.strength || (corridor.remainingDiamonds || 0) <= 0) {
            hero.state = "transporting";
            // rozpoczynaj transport z pozycji ≈õciany (obliczonej na podstawie remainingDiamonds)
            const maxD3 = corridor.maxDiamonds || 100;
            const remD3 = Math.max(0, Math.min(maxD3, corridor.remainingDiamonds ?? maxD3));
            const leftRatio3 = (corridor.wallStart || 0.1) + (1 - remD3 / maxD3) * (1 - (corridor.wallStart || 0.1));
            const wallPos = leftRatio3 * DIST;
            hero.position = wallPos;
            hero._targetPosition = wallPos;
            hero._currentPosition = wallPos;
          }
          break;
          
        case "transporting":
          // P≈Çynny ruch powrotny
          hero._targetPosition = Math.max(0, hero._targetPosition - speed);
          
          // Interpolacja pozycji dla p≈Çynnego ruchu
          const returnProgress = Math.min(1, dt * 10);
          hero._currentPosition += (hero._targetPosition - hero._currentPosition) * returnProgress;
          hero.position = hero._currentPosition;
          
          if (hero._targetPosition <= 0) {
            hero.state = "unloading";
            // ustaw czas roz≈Çadunku i zainicjuj wewnƒôtrzne liczniki transferu
            const ut = (typeof hero.unloadTime === "number") ? hero.unloadTime : 5 / (hero.strength || 1);
            // FIX: Czas roz≈Çadunku proporcjonalny do ≈Çadunku, aby utrzymaƒá sta≈ÇƒÖ szybko≈õƒá
            const fullLoadAmount = hero.strength || 1;
            const currentLoad = hero.currentLoad || 0;
            const timeForLoad = ut * (currentLoad / Math.max(1, fullLoadAmount));
            // store in seconds for timers
            hero.unloadTimer = timeForLoad;
            hero._unloadInitial = timeForLoad;
            // amount that should be transferred from hero to bucket during unloading
            hero._unloadRemaining = currentLoad;
            
            // Wyczy≈õƒá ≈Çadunek bohatera, bo diamenty sƒÖ teraz w "locie"
            const amountToAnimate = hero.currentLoad;
            hero.currentLoad = 0;

            if (amountToAnimate > 0) {
              const durMs = (hero.unloadTimer || 1) * 1000;
              animateTransferInCorridor(i, amountToAnimate, durMs);
            }
            
            // Ustaw pozycjƒô na 0
            hero.position = 0;
            hero._targetPosition = 0;
            hero._currentPosition = 0;
          }
          break;
          
        case "unloading":
          // Odejmuj czas od timera
          if (hero.unloadTimer > 0) {
            hero.unloadTimer -= dt;
          }

          // Gdy timer dobiegnie ko≈Ñca, zdecyduj co dalej
          if (hero.unloadTimer <= 0) {
            // Sprawd≈∫, czy wiadro ma miejsce i czy sƒÖ diamenty do wykopania
            const bucketHasSpace = (corridor.bucketAmount || 0) < (corridor.bucketCapacity || 100);
            if ((corridor.remainingDiamonds || 0) > 0 && bucketHasSpace) {
              // Je≈õli sƒÖ diamenty i wiadro ma miejsce - wr√≥ƒá do pracy
              hero.state = 'commuting';
            } else {
              // Je≈õli nie ma diament√≥w lub wiadro jest pe≈Çne - przejd≈∫ w stan bezczynno≈õci
              hero.state = 'idle';
            }
            hero.position = 0;
            hero._targetPosition = 0;
            hero._currentPosition = 0;
            // Wyczyszczenie starych danych o roz≈Çadunku
            hero._unloadInitial = undefined;
            hero._unloadRemaining = undefined;
          }
          break;
          
        case "idle":
          const bucketHasSpace = (corridor.bucketAmount || 0) < (corridor.bucketCapacity || 100);
          if (bucketHasSpace && (hero.currentLoad || 0) > 0) {
            // Je≈õli wiadro ma miejsce i bohater ma ≈Çadunek - roz≈Çaduj
            hero.state = "unloading";
            const ut = (typeof hero.unloadTime === "number") ? hero.unloadTime : 5 / (hero.strength || 1);
            // FIX: Wzn√≥w roz≈Çadunek z proporcjonalnym czasem dla reszty ≈Çadunku
            const fullLoadAmount = hero.strength || 1;
            const remainingLoad = hero.currentLoad || 0;
            const timeForRemaining = ut * (remainingLoad / Math.max(1, fullLoadAmount));
            hero.unloadTimer = timeForRemaining;
            hero._unloadInitial = timeForRemaining;
            hero._unloadRemaining = hero.currentLoad || 0;
            // Wzn√≥w tak≈ºe animacjƒô dla pozosta≈Çych diament√≥w
            const totalVisual = Math.min(Math.max(0, Math.round(hero._unloadRemaining || 0)), DIAMOND_SPRITE_MAX);
            if (totalVisual > 0) {
              const durMs = (hero.unloadTimer || 1) * 1000;
              animateTransferInCorridor(i, totalVisual, durMs);
            }
          } else if (corridor.remainingDiamonds > 0 && bucketHasSpace) {
            // Tylko je≈õli wiadro ma miejsce i sƒÖ diamenty do kopania
            hero.state = "commuting";
          }
          // Je≈õli wiadro jest pe≈Çne - pozostaw w stanie idle
          break;
      }
      
      if (hero.state !== "idle" && corridor.remainingDiamonds <= 0 && hero.currentLoad === 0) {
        hero.state = "idle";
      }
    }
    
    if (diamondsGained > 0) {
      team.forEach(hero => {
        if (!hero) return;
        if (hero.currentLoad === 0 && hero.state === "commuting") {
          hero.exp = (hero.exp || 0) + 2;
          if (hero.exp >= 100) {
            hero.level = (hero.level || 1) + 1;
            hero.exp -= 100;
            hero.mining = Math.floor(hero.mining * 1.1 + 1);
            hero.strength = Math.floor(hero.strength * 1.1 + 1);
            hero.speed *= 1.03;
          }
        }
      });
      saveGame();
    }
    
    // rendering jest teraz d≈Çawiony w g≈Ç√≥wnej pƒôtli, aby nie niszczyƒá element√≥w klikalnych co klatkƒô
    windziarzGameLoop(dt);
  }

  function updateMiningBoost() {
    miningBoostMultiplier = equippedTools.reduce((acc, t) => acc * (t.bonus || 1), 1);
  }

  function saveGame() {
    try {
      const state = { 
        // playerDiamonds usuniƒôte - u≈ºywamy safeDiamonds
        team, 
        corridors, 
        equippedTools, 
        windziarzTeam, 
        windziarzPurchased,
        kurierzyTeam,
        kurierzyPurchased,
        transportDiamonds,
        safeDiamonds
      };
      localStorage.setItem("diamondMineGameState", JSON.stringify(state));
      localStorage.setItem('platformDiamonds', transportDiamonds || 0);
    } catch (e) {
      console.warn("B≈ÇƒÖd zapisu stanu gry", e);
    }
  }

  let windziarzeData = [];
  let windziarzTeam = [];
  let graConfig = { liftAfterCollectionOf: 1000 };
  let elevatorEnabled = false;
  let elevatorDiamonds = 0;
  let windziarzPurchased = false;

  async function loadGraConfig() {
    try {
      const res = await fetch("gra.json");
      if (!res.ok) throw new Error("B≈ÇƒÖd ≈Çadowania gra.json");
      graConfig = await res.json();
    } catch (e) { graConfig = { liftAfterCollectionOf: 1000 }; }
  }

  async function loadWindziarze() {
    try {
      const res = await fetch("windziarze.json");
      if (!res.ok) throw new Error("B≈ÇƒÖd ≈Çadowania windziarze.json");
      windziarzeData = await res.json();
    } catch (e) { windziarzeData = []; }
  }

  async function loadKurierzy() {
    try {
      const res = await fetch("kurierzy.json");
      if (!res.ok) throw new Error("B≈ÇƒÖd ≈Çadowania kurierzy.json");
      kurierzyData = await res.json();
    } catch (e) { kurierzyData = []; }
  }

  function checkElevatorEnabled() {
    // Sprawd≈∫ ≈ÇƒÖcznƒÖ ilo≈õƒá diament√≥w (sejf + platforma)
    const totalDiamonds = safeDiamonds + transportDiamonds;
    const shouldBeEnabled = Number(totalDiamonds) >= Number(graConfig.liftAfterCollectionOf) || windziarzPurchased;
    console.log(`checkElevatorEnabled: safeDiamonds=${safeDiamonds}, transportDiamonds=${transportDiamonds}, totalDiamonds=${totalDiamonds}, required=${graConfig.liftAfterCollectionOf}, windziarzPurchased=${windziarzPurchased}, shouldBeEnabled=${shouldBeEnabled}, elevatorEnabled=${elevatorEnabled}`);
    if (shouldBeEnabled && !elevatorEnabled) {
      elevatorEnabled = true;
      const windziarzeShop = document.getElementById("windziarze-shop");
      if (windziarzeShop) {
        windziarzeShop.style.display = "block";
      }
      renderWindziarzeShop();
      renderKurierzyShop();
      renderElevator();
    }
  }

  function renderWindziarzeShop() {
    let shopSection = document.getElementById("windziarze-shop");
    if (!shopSection) {
      shopSection = document.createElement("section");
      shopSection.className = "shop-container";
      shopSection.id = "windziarze-shop";
      shopSection.setAttribute("aria-label", "Sklep windziarzy");
      const title = document.createElement("div");
      title.className = "shop-title";
      title.textContent = "Sklep windziarzy";
      shopSection.appendChild(title);
      const list = document.createElement("div");
      list.className = "shop-list";
      list.id = "windziarze-list";
      list.setAttribute("role", "list");
      shopSection.appendChild(list);
      document.getElementById("app").appendChild(shopSection);
    }
    const windziarzeList = document.getElementById("windziarze-list");
    windziarzeList.innerHTML = "";
    shopSection.style.display = elevatorEnabled ? "block" : "none";
    if (!elevatorEnabled) return;
    for (const wzBase of windziarzeData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = wzBase.name;
      const icon = document.createElement("div");
      icon.className = "shop-icon";
      if (wzBase.image) {
        const img = document.createElement("img");
        img.src = `images/${wzBase.image}`;
        img.alt = wzBase.name;
        img.style.width = "58px";
        img.style.height = "58px";
        img.style.objectFit = "cover";
        img.onerror = () => {
          img.remove();
          icon.textContent = wzBase.icon;
        };
        icon.appendChild(img);
      } else {
        icon.textContent = wzBase.icon;
      }
      item.appendChild(icon);
      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = wzBase.name;
      item.appendChild(name);
      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `üíé ${formatNumber(wzBase.cost)}`;
      item.appendChild(cost);
      item.onclick = () => {
        showWindziarzPurchasePopup(wzBase);
      };
      windziarzeList.appendChild(item);
    }
  }

  function renderKurierzyShop() {
    let shopSection = document.getElementById("kurierzy-shop");
    if (!shopSection) {
      shopSection = document.createElement("section");
      shopSection.className = "shop-container";
      shopSection.id = "kurierzy-shop";
      shopSection.setAttribute("aria-label", "Sklep kurier√≥w");
      const title = document.createElement("div");
      title.className = "shop-title";
      title.textContent = "Sklep kurier√≥w";
      shopSection.appendChild(title);
      const list = document.createElement("div");
      list.className = "shop-list";
      list.id = "kurierzy-list";
      list.setAttribute("role", "list");
      shopSection.appendChild(list);
      document.getElementById("app").appendChild(shopSection);
    }
    const kurierzyList = document.getElementById("kurierzy-list");
    kurierzyList.innerHTML = "";
    shopSection.style.display = "block"; // Kurierzy zawsze dostƒôpni
    console.log(`renderKurierzyShop: kurierzyData.length=${kurierzyData.length}`);
    for (const kurierBase of kurierzyData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = kurierBase.name;
      const icon = document.createElement("div");
      icon.className = "shop-icon";
      if (kurierBase.image) {
        const img = document.createElement("img");
        img.src = `images/${kurierBase.image}`;
        img.alt = kurierBase.name;
        img.style.width = "58px";
        img.style.height = "58px";
        img.style.objectFit = "cover";
        img.onerror = () => {
          img.remove();
          icon.textContent = kurierBase.icon;
        };
        icon.appendChild(img);
      } else {
        icon.textContent = kurierBase.icon;
      }
      item.appendChild(icon);
      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = kurierBase.name;
      item.appendChild(name);
      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `üíé ${formatNumber(kurierBase.cost)}`;
      item.appendChild(cost);
      item.onclick = () => {
        showKurierPurchasePopup(kurierBase);
      };
      kurierzyList.appendChild(item);
    }
  }

  function updateWindziarzProgress(wz) {
    const progressRing = document.getElementById(`windziarz-progress-${wz.id}`);
    if (!progressRing) return;

    let progress = 0;
    
    // Usu≈Ñ wszystkie klasy stan√≥w
    progressRing.classList.remove('moving', 'loading', 'returning', 'unloading', 'active');
    
    switch (wz.state) {
      case "moving":
        progressRing.classList.add('moving', 'active');
        // Postƒôp ruchu do celu
        if (wz.target > 0) {
          progress = Math.min(1, Math.abs(wz.position - wz.target) / Math.abs(wz.target));
          progress = (1 - progress) * 360; // Konwersja na stopnie (0-360)
        }
        break;
        
      case "loading":
        progressRing.classList.add('loading', 'active');
        // Postƒôp ≈Çadowania
        if (wz.loadingTimer !== undefined && wz.loadingTimer > 0) {
          const initialTime = wz.loadingTimer + (wz.carried / (wz.loadingspeed || 50));
          progress = ((initialTime - wz.loadingTimer) / initialTime) * 360;
        }
        break;
        
      case "returning":
        progressRing.classList.add('returning', 'active');
        // Postƒôp powrotu do g√≥ry na podstawie rzeczywistych wysoko≈õci
        let totalHeight = 0;
        if (wz.position > 0) {
          for (let i = 0; i < Math.min(wz.position, corridors.length); i++) {
            const corridorEl = teamContainer.querySelector(`[data-corridor-index="${i}"]`);
            if (corridorEl) {
              totalHeight += corridorEl.offsetHeight;
            }
          }
        }
        progress = (1 - (totalHeight / teamContainer.offsetHeight)) * 360;
        break;
        
      case "unloading":
        progressRing.classList.add('unloading', 'active');
        // Postƒôp roz≈Çadunku
        if (wz.unloadingTimer !== undefined && wz.unloadingTimer > 0) {
          const initialTime = wz.unloadingTimer + (wz.carried / (wz.loadingspeed || 50));
          progress = ((initialTime - wz.unloadingTimer) / initialTime) * 360;
        }
        break;
        
      default:
        // Stan idle - bez postƒôpu
        progress = 0;
        break;
    }
    
    // Ustaw postƒôp w CSS
    progressRing.style.setProperty('--progress', `${progress}deg`);
  }

  function windziarzGameLoop(dt) {
    // Windziarze dzia≈ÇajƒÖ je≈õli zostali kupieni, niezale≈ºnie od elevatorEnabled
    if (!windziarzPurchased) return;
    
    for (const wz of windziarzTeam) {
      switch (wz.state) {
        case "idle":
          wz.position = 0;
          wz.carried = 0;
          
          // Sprawd≈∫ czy sƒÖ wiadra z diamentami do zebrania
          let foundBucket = false;
          let totalBuckets = 0;
          for (let idx = 1; idx < corridors.length; idx++) {
            const bucketAmount = corridors[idx].bucketAmount || 0;
            totalBuckets += bucketAmount;
            if (bucketAmount > 0) {
              foundBucket = true;
              console.log(`Windziarz w idle: znaleziono wiadro ${idx} z ${bucketAmount} diamentami`);
              break;
            }
          }
          
          console.log(`Windziarz w idle: totalBuckets=${totalBuckets}, foundBucket=${foundBucket}, corridors.length=${corridors.length}`);
          
          if (foundBucket) {
            // Je≈õli sƒÖ wiadra z diamentami, id≈∫ je zbieraƒá
            console.log("Windziarz: przechodzƒô z idle do moving");
            wz.state = "moving";
            wz.target = 0; // Zacznie szukaƒá od pozycji 1
          } else {
            // Je≈õli nie ma diament√≥w, pozosta≈Ñ w idle
            console.log("Windziarz: pozostajƒô w idle - brak wiadel z diamentami");
            wz.state = "idle";
            wz.target = 0;
          }
          break;
        case "moving":
          // Debug log usuniƒôty
          if (wz.carried >= (wz.capacity || 1000)) {
            console.log("Windziarz pe≈Çny, wraca na g√≥rƒô");
            wz.state = "returning";
            wz.target = 0;
            break;
          }
          // szukaj najbli≈ºszego wiadra z diamentami od aktualnej pozycji (w d√≥≈Ç)
          let found = false;
          for (let idx = Math.round(Math.max(1, wz.position)); idx < corridors.length; idx++) {
            const bucketAmount = corridors[idx].bucketAmount || 0;
            console.log(`Windziarz sprawdza korytarz ${idx}: ${bucketAmount} diament√≥w (corridors.length=${corridors.length})`);
            if (bucketAmount > 0) {
              wz.target = idx;
              found = true;
              console.log(`Znalaz≈Çem wiadro w korytarzu ${idx} z ${bucketAmount} diamentami`);
              break;
            }
          }
          if (!found) {
            console.log("Nie znalaz≈Çem ≈ºadnego wiadra z diamentami");
            wz.state = "returning";
            wz.target = 0;
            break;
          }
          // p≈Çynny ruch windziarza do wybranego wiadra
          if (Math.abs(wz.position - wz.target) > 0.01) {
            wz.position += Math.sign(wz.target - wz.position) * (wz.speed || 1) * dt * 2;
          } else {
            wz.position = wz.target;
            wz.state = "loading";
            
            // W stanie "moving", gdy windziarz dociera do wiadra:
            wz.state = "loading";
            console.log(`Windziarz przechodzi do stanu loading, target: ${wz.target}`);

            const corridorEl = teamContainer.querySelector(`[data-corridor-index="${wz.target}"]`);
            const windziarzEl = document.getElementById(`windziarz-${wz.id}`);
            console.log(`Windziarz DEBUG - target: ${wz.target}, corridorEl:`, !!corridorEl, `windziarzEl:`, !!windziarzEl);
            if (!corridorEl) console.log(`Nie znaleziono korytarza [data-corridor-index="${wz.target}"]`);
            if (!windziarzEl) console.log(`Nie znaleziono windziarza #windziarz-${wz.id}`);

            if (corridorEl && windziarzEl) {
                const bucketEl = corridorEl.querySelector('.bucket');
                const corridor = corridors[wz.target];
                console.log(`Windziarz Bucket element:`, bucketEl, `Corridor data:`, corridor);
                
                if (bucketEl && corridor) {
                    const startRect = bucketEl.getBoundingClientRect();
                    const endRect = windziarzEl.getBoundingClientRect();
                    const amountToLoad = Math.min(corridor.bucketAmount || 0, (wz.capacity || 1000) - (wz.carried || 0));
                    const loadingSpeed = wz.loadingspeed || 50;
                    const duration = (amountToLoad / loadingSpeed);
                    
                    console.log(`Windziarz ≈Åadowanie: bucketAmount=${corridor.bucketAmount}, carried=${wz.carried}, capacity=${wz.capacity}`);
                    console.log(`Windziarz ≈Åadowanie: amountToLoad=${amountToLoad}, loadingSpeed=${loadingSpeed}, duration=${duration}s`);
                    
                    // Ustaw timer na czas trwania ≈Çadowania
                    wz.loadingTimer = duration;
                    console.log(`Windziarz Ustawiono loadingTimer: ${wz.loadingTimer}s`);
                    
                    // Wyczy≈õƒá wiadro, diamenty sƒÖ w locie
                    corridor.bucketAmount = Math.max(0, corridor.bucketAmount - amountToLoad);
                    
                    // NATYCHMIAST aktualizuj carried, animacja jest tylko wizualna
                    wz.carried = (wz.carried || 0) + amountToLoad;
                    console.log(`Windziarz Natychmiast za≈Çadowano ${amountToLoad}, carried: ${wz.carried}`);
                    
                    const onDiamondReach = (value) => {
                      // Callback dla animacji - ju≈º nie potrzebny dla logiki
                      console.log(`Windziarz Animacja diamentu zako≈Ñczona: ${value}`);
                    };
                    spawnDiamondSprites(startRect, endRect, amountToLoad, duration * 1000, onDiamondReach);
                } else {
                    console.log("Windziarz Brak bucket element lub corridor data");
                }
            } else {
                console.log("Windziarz Nie znaleziono corridor element lub windziarz element");
            }
          }
          break;
        case "loading":
          // Debug log usuniƒôty
          // Odejmuj czas od timera
          if (wz.loadingTimer > 0) {
            wz.loadingTimer -= dt;
          }

          // Gdy timer dobiegnie ko≈Ñca, zdecyduj co dalej
          if (wz.loadingTimer <= 0) {
            console.log("Windziarz Timer ≈Çadowania dobieg≈Ç ko≈Ñca");
            const corridor = corridors[wz.target];
            console.log(`Windziarz po ≈Çadowaniu: carried=${wz.carried}, capacity=${wz.capacity}, bucketAmount=${corridor?.bucketAmount || 0}`);
            if (wz.carried >= (wz.capacity || 1000)) {
                console.log("Windziarz pe≈Çny, wraca na g√≥rƒô");
                wz.state = "returning";
                wz.target = 0;
            } else if ((corridor.bucketAmount || 0) <= 0) {
                console.log("Windziarz Wiadro puste, szukam dalej");
                // Je≈õli wiadro jest puste, a my nie jeste≈õmy pe≈Çni, szukaj dalej
                if (wz.carried < (wz.capacity || 1000) && wz.target < corridors.length - 1) {
                  wz.state = "moving";
                  wz.target = wz.target + 1;
                  console.log(`Windziarz Przechodzƒô do korytarza ${wz.target}`);
                } else {
                  console.log("Windziarz Brak wiƒôcej korytarzy, wracam na g√≥rƒô");
                  wz.state = "returning";
                  wz.target = 0;
                }
            } else {
                console.log("Windziarz Wiadro ma jeszcze diamenty, ≈Çadujƒô dalej");
                // Wiadro ma jeszcze diamenty i windziarz nie jest pe≈Çny - kontynuuj ≈Çadowanie
                const amountToLoad = Math.min(corridor.bucketAmount || 0, (wz.capacity || 1000) - (wz.carried || 0));
                if (amountToLoad > 0) {
                  const loadingSpeed = wz.loadingspeed || 50;
                  const duration = (amountToLoad / loadingSpeed);
                  wz.loadingTimer = duration;
                  
                  // NATYCHMIAST dodaj diamenty do carried i usu≈Ñ z wiadra
                  wz.carried = (wz.carried || 0) + amountToLoad;
                  corridor.bucketAmount = Math.max(0, corridor.bucketAmount - amountToLoad);
                  
                  console.log(`Windziarz Kontynuujƒô ≈Çadowanie: ${amountToLoad} diament√≥w przez ${duration}s, carried: ${wz.carried}, bucketAmount: ${corridor.bucketAmount}`);
                } else {
                  console.log("Windziarz Nie mo≈ºna wiƒôcej za≈Çadowaƒá, wracam na g√≥rƒô");
                  wz.state = "returning";
                  wz.target = 0;
                }
            }
          }
          break;
        case "returning":
          // p≈Çynny ruch do g√≥ry
          if (wz.position > 0.01) {
            wz.position = Math.max(0, wz.position - (wz.speed || 1) * dt * 2);
          } else {
            wz.position = 0;
            wz.state = "unloading";
            
            const windziarzEl = document.getElementById(`windziarz-${wz.id}`);
            if (windziarzEl && wz.carried > 0) {
                const unloadSpeed = wz.loadingspeed || 50;
                const amountToUnload = wz.carried;
                const duration = (amountToUnload / unloadSpeed); // Czas w sekundach

                // Ustaw timer na czas trwania roz≈Çadunku
                wz.unloadingTimer = duration;

                console.log(`Windziarz Rozpoczynam roz≈Çadunek ${amountToUnload} diament√≥w na platformƒô przez ${duration}s`);
                
                // Diamenty bƒôdƒÖ dodawane stopniowo przez czas roz≈Çadunku
                // (nie dodajemy ich od razu - to siƒô dzieje w case "unloading")
                
                // Zapisz grƒô gdy rozpocznie siƒô roz≈Çadunek
                saveGame();
            } else {
                // Je≈õli nie ma co roz≈Çadowaƒá, przejd≈∫ od razu dalej
                wz.unloadingTimer = 0;
                wz.state = "idle";
            }
          }
          break;
        case "unloading":
          // Odejmuj czas od timera
          if (wz.unloadingTimer > 0) {
            wz.unloadingTimer -= dt;
            
            // Dodaj diamenty stopniowo przez czas roz≈Çadunku
            const totalAmount = wz.carried || 0;
            const unloadingSpeed = wz.loadingspeed || 50;
            const amountPerSecond = unloadingSpeed;
            const amountToAdd = Math.min(amountPerSecond * dt, wz.carried);
            
            if (amountToAdd > 0) {
              // Dodaj diamenty do platformy
              transportDiamonds += amountToAdd;
              wz.carried = Math.max(0, wz.carried - amountToAdd);
              
              // Aktualizuj licznik platformy
              updatePlatformCounter();
              
              console.log(`Windziarz Roz≈Çadunek w toku: +${amountToAdd.toFixed(2)}, pozosta≈Ço ${wz.carried.toFixed(2)}, timer: ${wz.unloadingTimer.toFixed(2)}s`);
            }
          }
          
          // Gdy timer dobiegnie ko≈Ñca, przejd≈∫ do stanu bezczynno≈õci
          if (wz.unloadingTimer <= 0) {
            // Dodaj pozosta≈Çe diamenty
            if (wz.carried > 0) {
              transportDiamonds += wz.carried;
              wz.carried = 0;
              updatePlatformCounter();
              console.log(`Windziarz Roz≈Çadunek zako≈Ñczony, wszystkie diamenty na platformie: transportDiamonds=${transportDiamonds}`);
            }
            
            wz.state = "idle";
            saveGame();
          }
          break;
      }
    }
    
    // Aktualizuj paski postƒôpu tylko gdy co≈õ siƒô zmieni≈Ço
    if (windziarzTeam.length > 0) {
      windziarzTeam.forEach(wz => {
        updateWindziarzProgress(wz);
      });
      
      // Aktualizuj pionowy pasek postƒôpu w szybie
      updateElevatorProgress();
    }
  }

  function getRandomDiamonds() {
    return Math.floor(Math.random() * (100000 - 100 + 1)) + 100;
  }

  // Inicjalizacja sta≈Çego kontenera transportowego
  function initializeTransportContainer() {
    console.log('=== INICJALIZACJA KONTENERA TRANSPORTOWEGO ===');
    
    // Dodaj event listener dla platformy roz≈Çadunkowej
    const platformEl = document.getElementById('unloading-platform');
    if (platformEl) {
      console.log('‚úÖ Znaleziono platformƒô, dodajƒô event listener');
      platformEl.onclick = function() {
        console.log('=== KLIKNIƒòTO PLATFORMƒò (STA≈ÅY KONTENER) ===');
        
        if (transportDiamonds > 0) {
          const amount = transportDiamonds;
          
          transportDiamonds = 0;
          safeDiamonds += amount;
          
          updatePlatformCounter();
          updateSafeDisplay();
          
          console.log(`Przeniesiono ${amount} diament√≥w z platformy do sejfu. Sejf ma teraz: ${safeDiamonds}`);
          
          // Animacja diament√≥w
          const safeEl = document.getElementById('safe');
          if (safeEl && typeof spawnDiamondSprites === 'function') {
            const startRect = platformEl.getBoundingClientRect();
            const endRect = safeEl.getBoundingClientRect();
            spawnDiamondSprites(startRect, endRect, amount, 1000);
          }
          
          saveGame();
        } else {
          console.log('Platforma jest pusta');
        }
      };
    } else {
      console.log('‚ùå Platforma nie zosta≈Ça znaleziona!');
    }
    
    // Dodaj event listener dla sejfu
    const safeEl = document.getElementById('safe');
    if (safeEl) {
      console.log('‚úÖ Znaleziono sejf, dodajƒô event listener');
      safeEl.onclick = function() {
        console.log('=== KLIKNIƒòTO SEJF (STA≈ÅY KONTENER) ===');
        // Tutaj mo≈ºesz dodaƒá funkcjonalno≈õƒá sejfu
      };
    } else {
      console.log('‚ùå Sejf nie zosta≈Ç znaleziony!');
    }
    
    // Renderuj poczƒÖtkowy stan kontenera
    renderTransportContainer();
    updatePlatformCounter();
    updateSafeDisplay();
    
    // Sprawd≈∫ czy elementy istniejƒÖ, je≈õli nie - spr√≥buj ponownie za 500ms
    if (!document.getElementById('unloading-platform') || !document.getElementById('safe')) {
      console.log('‚ö†Ô∏è Elementy transportowe nie istniejƒÖ, ponawiam pr√≥bƒô za 500ms...');
      console.log('üîç Sprawdzam DOM:', {
        'unloading-platform': !!document.getElementById('unloading-platform'),
        'safe': !!document.getElementById('safe'),
        'transport-container': !!document.getElementById('transport-container')
      });
      setTimeout(initializeTransportContainer, 500);
    } else {
      console.log('‚úÖ Wszystkie elementy transportowe zosta≈Çy znalezione!');
    }
  }

  async function init() {
    await loadGraConfig();
    await loadWindziarze();
    await loadKurierzy();
    console.log("Kurierzy za≈Çadowani:", kurierzyData);
    console.log("kurierzyTeam po za≈Çadowaniu:", kurierzyTeam);
    
    // Renderuj korytarze - usuniƒôte, u≈ºywamy renderTeam()
    console.log("Rozpoczynam renderowanie korytarzy");
    
    await loadNames();
    heroesData = await loadJSON("heroes.json", defaultHeroesData);
    toolsData = await loadJSON("items.json", defaultToolsData);

    const savedState = localStorage.getItem("diamondMineGameState");
    if (savedState) {
      try {
        const state = JSON.parse(savedState);
        // playerDiamonds jest przestarza≈Çe - u≈ºywamy safeDiamonds
        if (state.corridors && state.team) {
          for (let i = 0; i < state.corridors.length; i++) {
            const sc = state.corridors[i];
            corridors[i] = {
              wallHP: sc.wallHP ?? (10000 + Math.floor(Math.random() * 90000)),
              maxDiamonds: sc.maxDiamonds ?? getRandomDiamonds(),
              remainingDiamonds: (typeof sc.remainingDiamonds === 'number') ? sc.remainingDiamonds : (sc.maxDiamonds ?? getRandomDiamonds()),
              wallStart: sc.wallStart ?? 0.1,
              bucketCapacity: sc.bucketCapacity ?? 100,
              bucketAmount: (typeof sc.bucketAmount === 'number') ? sc.bucketAmount : 0
            };
            
            team[i] = state.team[i] ? { ...state.team[i] } : null;
            // Uzupe≈Çnij brakujƒÖce instanceName po wczytaniu starego zapisu
            if (team[i] && !team[i].instanceName) {
              team[i].instanceName = generateHeroName();
            }
            
            // Dodaj w≈Ça≈õciwo≈õci dla p≈Çynnego ruchu je≈õli ich brakuje
            if (team[i]) {
              if (typeof team[i]._targetPosition === 'undefined') {
                team[i]._targetPosition = team[i].position || 0;
              }
              if (typeof team[i]._currentPosition === 'undefined') {
                team[i]._currentPosition = team[i].position || 0;
              }
            }
            
            // Je≈õli korytarz ma bohatera, ustaw pojemno≈õƒá wiadra na 10x Strength
            if (team[i]) {
              corridors[i].bucketCapacity = (team[i].strength || 1) * 10;
            }
          }
        }
        equippedTools = state.equippedTools || [];
        windziarzTeam = (state.windziarzTeam || []).map(w => ({ ...w }));
        windziarzPurchased = !!state.windziarzPurchased;
        
        // Wczytaj system kurier√≥w
        kurierzyTeam = (state.kurierzyTeam || []).map(k => ({ ...k }));
        kurierzyPurchased = state.kurierzyPurchased || {};
        
        // Upewnij siƒô, ≈ºe kurierzy majƒÖ wszystkie potrzebne w≈Ça≈õciwo≈õci
        kurierzyTeam.forEach(kurier => {
          if (kurier) {
            if (typeof kurier.progress === 'undefined') kurier.progress = 0;
            if (typeof kurier.target === 'undefined') kurier.target = "platform";
            if (typeof kurier.direction === 'undefined') kurier.direction = "left";
            if (typeof kurier.carried === 'undefined') kurier.carried = 0;
            if (typeof kurier.currentLoad === 'undefined') kurier.currentLoad = 0;
            if (typeof kurier.loadingTimer === 'undefined') kurier.loadingTimer = 0;
            if (typeof kurier.unloadingTimer === 'undefined') kurier.unloadingTimer = 0;
            if (typeof kurier.capacity === 'undefined') kurier.capacity = 1000;
            if (typeof kurier.speed === 'undefined') kurier.speed = 1.0;
            if (typeof kurier.loadingspeed === 'undefined') kurier.loadingspeed = 50;
          }
        });
        
        // Wczytaj system transportu
        transportDiamonds = state.transportDiamonds || 0;
        safeDiamonds = state.safeDiamonds || 0;
        
        updateMiningBoost();
      } catch {
        localStorage.removeItem("diamondMineGameState");
      }
    } else {
      // Nowa gra: nie ma zapisanego stanu, wiƒôc zaczynamy z pustymi tablicami
      // Pierwszy korytarz zostanie dodany przez initializeFirstCorridor()
    }
    
    // Dodaj domy≈õlnego bohatera tylko je≈õli nie istnieje
    if (!team.some(h => h)) {
      // Upewnij siƒô, ≈ºe mamy pierwszy korytarz
      initializeFirstCorridor();
      team[1] = createHeroInstance(heroesData[0]); // U≈ºyj danych z heroes.json - kopacz w korytarzu 1

      // Ustaw pojemno≈õƒá wiadra na 10x Strength nowego bohatera
      const newBucketCapacity = (team[1].strength || 1) * 10;
      corridors[1].bucketCapacity = newBucketCapacity;
    }
    
    // Upewnij siƒô, ≈ºe wszyscy bohaterowie majƒÖ w≈Ça≈õciwo≈õci dla p≈Çynnego ruchu
    team.forEach(hero => {
      if (hero) {
        if (typeof hero._targetPosition === 'undefined') {
          hero._targetPosition = hero.position || 0;
        }
        if (typeof hero._currentPosition === 'undefined') {
          hero._currentPosition = hero.position || 0;
        }
      }
    });
    
    // Upewnij siƒô, ≈ºe mamy pierwszy korytarz
    initializeFirstCorridor();
    
    updateDiamondsDisplay();
    
    // Inicjalizuj sta≈Çy kontener transportowy
    initializeTransportContainer();
    
    renderTeam();
    renderHeroesShop();
    renderToolsShop();
    checkElevatorEnabled();
    renderWindziarzeShop();
    renderKurierzyShop();
    renderElevator();
    loop();
  }

  let lastTime = performance.now();
  let renderAccum = 0;
  const RENDER_INTERVAL = 0.05; // sekundy (20 FPS dla p≈Çynnego ruchu kopaczy)
  function loop() {
    const now = performance.now();
    const delta = (now - lastTime) / 1000;
    lastTime = now;
    gameLoopStep(delta);
    
    // Aktualizuj system transportu czƒô≈õciej dla p≈Çynnej animacji
    if (!window.transportAccum) window.transportAccum = 0;
    window.transportAccum += delta;
    if (window.transportAccum >= 0.016) { // 60 FPS dla transportu (1/60 ‚âà 0.016)
      updateTransportSystem(delta);
      window.transportAccum = 0;
    }
    
    renderAccum += delta;
    if (renderAccum >= RENDER_INTERVAL) {
      const sx = window.scrollX, sy = window.scrollY;
      renderTeam();
      if (window.scrollY !== sy || window.scrollX !== sx) window.scrollTo(sx, sy);
      renderAccum = 0;
    }
    requestAnimationFrame(loop);
  }

  btnReset.onclick = () => {
    localStorage.removeItem("diamondMineGameState");
    location.reload();
  };

  // --- KOP button delay logic ---
  const FREE_DIAMONDS_PER_HOUR = 2000;
  const FREE_DIAMONDS_DELAY = 500; // ms (zmniejszono z 1000)
  const REFRESH_DELAY = 60 * 60 * 1000; // 60 min in ms
  let freeDiamonds = FREE_DIAMONDS_PER_HOUR;
  let lastFreeDiamondsRefill = Date.now();
  let kopDelayUntil = 0;
  let kopRefreshUntil = 0;

  function refillFreeDiamondsIfNeeded() {
    const now = Date.now();
    if (now - lastFreeDiamondsRefill >= 3600 * 1000) {
      freeDiamonds = FREE_DIAMONDS_PER_HOUR;
      lastFreeDiamondsRefill = now;
      kopRefreshUntil = 0;
    }
  }

  function updateKopButtonState() {
    refillFreeDiamondsIfNeeded();
    const now = Date.now();
    let disabled = false;
    let progress = 0;
    let label = "Kop";
    
    if (kopDelayUntil > now) {
      disabled = true;
      progress = 1 - (kopDelayUntil - now) / FREE_DIAMONDS_DELAY;
      label = `Kop (${Math.ceil((kopDelayUntil-now)/1000)}s)`;
    } else if (freeDiamonds <= 0) {
      disabled = true;
      if (kopRefreshUntil > now) {
        progress = 1 - (kopRefreshUntil - now) / REFRESH_DELAY;
        const left = Math.ceil((kopRefreshUntil-now)/1000);
        label = `Do≈Çadowanie za ${Math.floor(left/60)}:${(left%60).toString().padStart(2,'0')}`;
      } else {
        // Refill
        freeDiamonds = FREE_DIAMONDS_PER_HOUR;
        lastFreeDiamondsRefill = now;
        kopRefreshUntil = 0;
        disabled = false;
        progress = 0;
        label = "Kop";
      }
    }
    
    btnMine.disabled = disabled;
    btnMine.textContent = label;
    
    // Aktualizuj pulƒô diament√≥w free
    updateFreeDiamondsPool();
    
    // Progress bar in button (istniejƒÖcy kod)
    btnMine.style.position = "relative";
    let progressBar = btnMine.querySelector('.kop-progress');
    if (!progressBar) {
      progressBar = document.createElement('div');
      progressBar.className = 'kop-progress';
      progressBar.style.position = 'absolute';
      progressBar.style.left = 0;
      progressBar.style.top = 0;
      progressBar.style.height = '100%';
      progressBar.style.width = '0%';
      progressBar.style.background = 'rgba(255,255,255,0.18)';
      progressBar.style.borderRadius = '14px';
      progressBar.style.pointerEvents = 'none';
      progressBar.style.transition = 'width 0.2s linear';
      btnMine.appendChild(progressBar);
    }
    progressBar.style.width = Math.round(progress*100) + '%';
    progressBar.style.display = disabled ? 'block' : 'none';
  }

  // Nowa funkcja do aktualizacji puli diament√≥w free
  function updateFreeDiamondsPool() {
    let poolContainer = btnMine.querySelector('.free-diamonds-pool');
    let poolFill = btnMine.querySelector('.free-diamonds-fill');
    let poolLabel = btnMine.querySelector('.free-diamonds-label');
    
    // Stw√≥rz elementy puli je≈õli nie istniejƒÖ
    if (!poolContainer) {
      poolContainer = document.createElement('div');
      poolContainer.className = 'free-diamonds-pool';
      btnMine.appendChild(poolContainer);
      
      poolFill = document.createElement('div');
      poolFill.className = 'free-diamonds-fill';
      poolContainer.appendChild(poolFill);
      
      poolLabel = document.createElement('div');
      poolLabel.className = 'free-diamonds-label';
      poolContainer.appendChild(poolLabel);
    }
    
    // Oblicz procent wype≈Çnienia puli
    const poolPercentage = (freeDiamonds / FREE_DIAMONDS_PER_HOUR) * 100;
    poolFill.style.width = `${poolPercentage}%`;
    
    // Aktualizuj etykietƒô
    poolLabel.textContent = `${freeDiamonds}/${FREE_DIAMONDS_PER_HOUR}`;
    
    // Zmie≈Ñ kolor w zale≈ºno≈õci od stanu puli
    if (freeDiamonds <= 0) {
      poolFill.style.background = '#f44336'; // Czerwony gdy pusta
      poolLabel.style.color = '#f44336';
    } else if (freeDiamonds < FREE_DIAMONDS_PER_HOUR * 0.3) {
      poolFill.style.background = '#ff9800'; // Pomara≈Ñczowy gdy ma≈Ço
      poolLabel.style.color = '#ff9800';
    } else {
      poolFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a, #cddc39)'; // Zielony gdy du≈ºo
      poolLabel.style.color = '#4caf50';
    }
  }

  setInterval(updateKopButtonState, 200);

  btnMine.onclick = () => {
    const now = Date.now();
    refillFreeDiamondsIfNeeded();
    if (kopDelayUntil > now || (freeDiamonds <= 0 && kopRefreshUntil > now)) return;
    
    if (freeDiamonds > 0) {
      // Losowo od 1 do 10 diament√≥w
      const diamondsToAdd = Math.min(freeDiamonds, Math.floor(Math.random() * 10) + 1);
      transportDiamonds += diamondsToAdd;
      freeDiamonds -= diamondsToAdd;
      kopDelayUntil = now + FREE_DIAMONDS_DELAY;
      updatePlatformCounter(); // Aktualizuj licznik platformy
      // NIE wywo≈Çujemy updateDiamondsDisplay() - licznik "Diamenty" siƒô nie zmienia dop√≥ki nie klikniesz platformy
      checkElevatorEnabled(); // Sprawd≈∫ czy winda powinna siƒô pojawiƒá (uwzglƒôdnia transportDiamonds)
      saveGame();
      
      try {
        const startRect = btnMine.getBoundingClientRect();
        const platformEl = document.getElementById('unloading-platform');
        if (platformEl) {
          const endRect = platformEl.getBoundingClientRect();
          // Wy≈õlij dok≈Çadnie tyle diament√≥w ile zosta≈Ço wygenerowane - do platformy
          spawnDiamondSprites(startRect, endRect, diamondsToAdd, 400);
        }
        // Brak animacji je≈õli platforma nie istnieje
      } catch (e) {
        console.log('Kop: B≈ÇƒÖd animacji:', e);
      }
      
      if (freeDiamonds <= 0) {
        kopRefreshUntil = now + REFRESH_DELAY;
      }
    }
    updateKopButtonState();
  };

  window.addEventListener('resize', () => {
    renderElevator();
  });

  init();

  function calculateMinerEfficiency(hero) {
    if (!hero) return 0;
    
    // Podstawowe statystyki
    const miningSpeed = hero.mining || 1; // diamenty na sekundƒô podczas kopania
    const movementSpeed = hero.speed || 1; // mno≈ºnik prƒôdko≈õci
    const strength = hero.strength || 1; // pojemno≈õƒá ≈Çadunku
    const unloadTime = hero.unloadTime || (5 / strength); // czas roz≈Çadunku
    
    // D≈Çugo≈õƒá korytarza (100 jednostek w grze)
    const corridorLength = 100;
    // Odleg≈Ço≈õƒá do ≈õciany (10% d≈Çugo≈õci korytarza + postƒôp kopania)
    const wallDistance = corridorLength * 0.1; // 10% d≈Çugo≈õci korytarza
    
    // Czas potrzebny na przej≈õcie do ≈õciany
    const travelTimeToWall = wallDistance / (movementSpeed * 50); // 50 to bazowa prƒôdko≈õƒá w grze
    
    // Czas potrzebny na nape≈Çnienie wiadra
    const fillTime = strength / miningSpeed;
    
    // Czas potrzebny na powr√≥t do poczƒÖtku
    const travelTimeBack = wallDistance / (movementSpeed * 50);
    
    // Ca≈Çkowity czas cyklu
    const totalCycleTime = travelTimeToWall + fillTime + travelTimeBack + unloadTime;
    
    // Ca≈Çkowita wydajno≈õƒá (diamenty na sekundƒô)
    const totalEfficiency = strength / totalCycleTime;
    
    return {
      totalEfficiency: totalEfficiency,
      cycleTime: totalCycleTime,
      travelTimeToWall: travelTimeToWall,
      fillTime: fillTime,
      travelTimeBack: travelTimeBack,
      unloadTime: unloadTime,
      details: {
        miningSpeed: miningSpeed,
        movementSpeed: movementSpeed,
        strength: strength,
        wallDistance: wallDistance
      }
    };
  }

  function formatEfficiency(efficiency) {
    if (efficiency <= 0) return "0 d/s";
    if (efficiency < 1) return `${efficiency.toFixed(2)} d/s`;
    if (efficiency < 10) return `${efficiency.toFixed(1)} d/s`;
    if (efficiency < 100) return `${Math.round(efficiency)} d/s`;
    if (efficiency < 1000) return `${Math.round(efficiency)} d/s`;
    return `${(efficiency / 1000).toFixed(1)}k d/s`;
  }

  function emptyBucket(corridorIndex) {
    const corridor = corridors[corridorIndex];
    if (corridor && corridor.bucketAmount > 0) {
        const amount = corridor.bucketAmount;
        corridor.bucketAmount = 0;
        
        // Przenie≈õ diamenty do platformy (nie do sejfu)
        transportDiamonds += amount;
        
        // Zaktualizuj licznik platformy
        updatePlatformCounter();
        
        // Animuj przeniesienie diament√≥w do platformy
        const bucketEl = document.querySelector(`[data-corridor-index="${corridorIndex}"] .bucket`);
        const platformEl = document.getElementById('unloading-platform');
        
        if (bucketEl && platformEl) {
            const startRect = bucketEl.getBoundingClientRect();
            const endRect = platformEl.getBoundingClientRect();
            
            spawnDiamondSprites(startRect, endRect, amount, 1000, () => {
                console.log(`Windziarz ${amount} diament√≥w przeniesionych do platformy`);
            });
        }
        
        // Zaktualizuj wy≈õwietlanie wiadra
        renderTeam();
    }
  }

  function updatePlatformCounter() {
    // Aktualizuj wy≈õwietlanie na platformie w sta≈Çym kontenerze
    const platformDiamondsEl = document.querySelector('#unloading-platform .platform-diamonds');
    if (platformDiamondsEl) {
        platformDiamondsEl.textContent = formatNumber(transportDiamonds);
    }
  }

  function updateSafeDisplay() {
    // Aktualizuj wy≈õwietlanie sejfu w sta≈Çym kontenerze
    const safeDiamondsEl = document.querySelector('#safe .safe-diamonds');
    if (safeDiamondsEl) {
        safeDiamondsEl.textContent = formatNumber(safeDiamonds);
    }
  }

  // Funkcja do renderowania kurier√≥w w sta≈Çym kontenerze transportowym
  function renderTransportContainer() {
    const kurierzyArea = document.getElementById('kurierzy-area');
    if (!kurierzyArea) return;
    
    // Wyczy≈õƒá obszar kurier√≥w
    kurierzyArea.innerHTML = '';
    
    if (kurierzyTeam.length > 0) {
      kurierzyTeam.forEach((kurier, index) => {
        const kurierEl = document.createElement("div");
        kurierEl.id = `kurier-${kurier.id}`;
        kurierEl.className = "kurier";
        kurierEl.style.position = "relative";
        kurierEl.style.display = "inline-block";
        kurierEl.style.margin = "0 5px";
        
        kurierEl.innerHTML = `
          <div class="kurier-icon">${kurier.icon}</div>
          <div class="kurier-load">${formatNumber(kurier.carried || 0)}/${formatNumber(kurier.capacity || 100)}</div>
          <div class="kurier-progress">Progress: ${(kurier.progress || 0).toFixed(3)}</div>
        `;
        
        // Dodaj wska≈∫nik stanu - u≈ºywamy klas CSS zamiast inline style
        const stateClasses = { 
          'idle': 'kurier-state-idle', 
          'moving-to-platform': 'kurier-state-moving-to-platform', 
          'loading': 'kurier-state-loading', 
          'moving': 'kurier-state-moving', 
          'moving-to-safe': 'kurier-state-moving-to-safe', 
          'returning': 'kurier-state-returning',
          'unloading': 'kurier-state-unloading' 
        };
        kurierEl.classList.add(stateClasses[kurier.state] || 'kurier-state-idle');
        
        // Podstawowe style
        kurierEl.style.padding = "4px 8px";
        kurierEl.style.fontSize = "0.8rem";
        kurierEl.style.color = "#ffffff";
        kurierEl.style.textAlign = "center";
        kurierEl.style.minWidth = "60px";
        
        // Dodaj klikniƒôcie na kuriera
        kurierEl.onclick = () => {
          showKurierPopup(kurier);
        };
        
        // Funkcja do obliczania pozycji poziomej kuriera
        // ZAKOTWIENIE PO LEWEJ STRONIE: progress 0 = lewa krawƒôd≈∫, progress 1 = prawa krawƒôd≈∫
        function calculateKurierPosition(progress, target) {
          // Sta≈Çe pozycje dla kurier√≥w w kontenerze transportowym
          const PLATFORM_WIDTH = 120;
          const SAFE_WIDTH = 120;
          const KURIER_WIDTH = 60;
          const CORRIDOR_PADDING = 12;
          
          // Pozycja startowa (platforma) - uwzglƒôdniam margin z CSS
          const platformStartPos = -25; // 20px - margin z CSS dla .kurierzy-area
          
          // Pozycja ko≈Ñcowa (sejf) - uwzglƒôdniam margin z CSS
          const containerWidth = kurierzyArea.offsetWidth;
          const safeEndPos = containerWidth - 75; // Koniec kontenera minus margin
          
          // Obszar ruchu kuriera (od platformy do sejfu)
          const moveAreaStart = platformStartPos; // 20px - platforma
          const moveAreaEnd = safeEndPos; // containerWidth-20 - sejf
          const moveAreaWidth = moveAreaEnd - moveAreaStart;
          
          // Debug: loguj obszar ruchu
          console.log(`Obszar ruchu: ${moveAreaStart}px ‚Üí ${moveAreaEnd}px (szeroko≈õƒá: ${moveAreaWidth}px)`);
          
          // ZAKOTWIENIE PO LEWEJ: progress 0 = lewa krawƒôd≈∫, progress 1 = prawa krawƒôd≈∫
          let leftPosition;
          
          // PROGRESS ABSOLUTNY: 0.0 = lewa krawƒôd≈∫, 1.0 = prawa krawƒôd≈∫
          // Niezale≈ºnie od kierunku ruchu!
          leftPosition = moveAreaStart + (moveAreaWidth * progress);
          
          // Debug: loguj obliczenia
          console.log(`calculateKurierPosition: progress=${progress}, target=${target}, leftPosition=${leftPosition}, containerWidth=${containerWidth}`);
          
          return leftPosition;
        }
        
        // Pozycjonowanie dla wszystkich stan√≥w
        let leftPosition;
        
        switch (kurier.state) {
          case "idle":
            // Kurier czeka przy platformie (lewa krawƒôd≈∫)
            leftPosition = calculateKurierPosition(0, "safe");
            break;
            
          case "loading":
            // Kurier ≈Çaduje przy platformie (lewa krawƒôd≈∫)
            leftPosition = calculateKurierPosition(0, "safe");
            break;
            
          case "moving":
            // Ruch do sejfu (od platformy do sejfu)
            if (kurier.target === "safe") {
              leftPosition = calculateKurierPosition(kurier.progress, "safe");
            } else {
              // Nieoczekiwany target - domy≈õlnie przy platformie
              leftPosition = calculateKurierPosition(0, "safe");
            }
            break;
            
          case "returning":
            // Ruch do platformy (od sejfu do platformy) - progress 1.0 ‚Üí 0.0
            leftPosition = calculateKurierPosition(kurier.progress, "platform");
            break;
            
          case "unloading":
            // Kurier roz≈Çadowuje przy sejfie (prawa krawƒôd≈∫)
            leftPosition = calculateKurierPosition(1, "safe");
            break;
            
          default:
            // Domy≈õlnie przy platformie (lewa krawƒôd≈∫)
            leftPosition = calculateKurierPosition(0, "safe");
            break;
        }
        
        if (leftPosition !== undefined) {
          kurierEl.style.position = "absolute";
          kurierEl.style.left = `${leftPosition}px`;
          kurierEl.style.top = "50%"; // Wy≈õrodkuj w pionie
          kurierEl.style.transform = "translateY(-50%)"; // Wy≈õrodkuj w pionie
          
          // Animacja tylko dla ruchu
          if (kurier.state === "moving") {
            kurierEl.style.transition = "left 0.05s ease-out";
          } else {
            kurierEl.style.transition = "none";
          }
          
          // Debug: loguj pozycjƒô
          console.log(`Kurier ${kurier.id} POZYCJA: ${leftPosition.toFixed(0)}px, stan=${kurier.state}, progress=${kurier.progress.toFixed(3)}, target=${kurier.target}`);
        }
        
        // Dodaj kuriera do obszaru
        kurierzyArea.appendChild(kurierEl);
      });
    } else {
      // Poka≈º informacjƒô o braku kurier√≥w
      const noKurierInfo = document.createElement("div");
      noKurierInfo.className = "no-kurier-info";
      noKurierInfo.innerHTML = `
        <div style="text-align: center; color: #999; padding: 10px;">
          <div>üöö</div>
          <div>Kup kuriera</div>
        </div>
        </div>
      `;
      kurierzyArea.appendChild(noKurierInfo);
    }
  }

  // W funkcji renderowania korytarza 0, w miejscu gdzie renderowane sƒÖ kurierzy
  // Usuniƒôto b≈Çƒôdny kod poza funkcjƒÖ

  // ... existing code ...
  // W funkcji renderCorridor, na poczƒÖtku
  // renderCorridor usuniƒôte - u≈ºywamy renderTeam()
  // ... existing code ...

  
  // ... existing code ...

})();
</script>
</body>
</html>
