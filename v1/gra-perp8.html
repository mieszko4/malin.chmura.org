<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Kopalnia Diamentów - Idle Clicker</title>
<link rel="stylesheet" href="styles.css" />
<style>
  /* efekt lotu diamentu do licznika */
  .diamond-sprite {
    position: fixed;
    font-size: 20px;
    transform: translate(-50%, -50%) scale(1);
    animation: diamond-fly 700ms cubic-bezier(.2,.7,.2,1) forwards;
    pointer-events: none;
    z-index: 9999;
    will-change: transform, opacity;
  }
  @keyframes diamond-fly {
    to {
      transform: translate(calc(-50% + var(--dx, 0px)), calc(-50% + var(--dy, -120px))) scale(0.6);
      opacity: 0;
    }
  }
  .loading-bar {
    position: absolute;
    bottom: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: 8px;
    background-color: #333;
    border: 1px solid #555;
    border-radius: 4px;
    overflow: hidden;
  }
  .loading-fill {
    width: 0%;
    height: 100%;
    background-color: #4caf50;
    border-radius: 4px;
    transition: width 0.2s linear;
  }
</style>
</head>
<body>
<button id="btn-reset" aria-label="Resetuj stan gry">Reset</button>
<div id="app" role="main">
  <div id="player-diamonds" aria-live="polite" aria-atomic="true">💎 Diamenty: 0</div>
  <section id="team" aria-label="Drużyna bohaterów i korytarze" role="list"></section>
  <button id="btn-mine" aria-label="Ręczne kopanie diamentów">Kop</button>
  <section class="shop-container" aria-label="Sklep bohaterów">
    <div class="shop-title">Sklep bohaterów</div>
    <div class="shop-list" id="heroes-list" role="list"></div>
  </section>
  <section class="shop-container" aria-label="Sklep narzędzi">
    <div class="shop-title">Sklep narzędzi</div>
    <div class="shop-list" id="tools-list" role="list"></div>
  </section>
</div>
<div id="popup" role="dialog" aria-modal="true" aria-labelledby="popup-title" aria-describedby="popup-desc">
  <div id="popup-content" tabindex="0">
    <h3 id="popup-title"></h3>
    <div id="popup-desc"></div>
    <button id="popup-action" class="action-btn"></button>
    <button id="popup-close">Zamknij</button>
  </div>
</div>
<script>
(() => {
  "use strict";

  function formatNumber(n) {
    n = Number(n) || 0;
    if (n < 1000) {
      return Math.floor(n).toString();
    }
    const si = [
      { value: 1e12, symbol: "t" },
      { value: 1e9, symbol: "b" },
      { value: 1e6, symbol: "m" },
      { value: 1e3, symbol: "k" }
    ];
    for (const item of si) {
      if (n >= item.value) {
        const val = n / item.value;
        return val.toFixed(2) + item.symbol;
      }
    }
    return n.toString();
  }

  const defaultHeroesData = [
    { id: 1, name: "Mały Kret", icon: "🐭", mining: 1, speed: 1, strength: 1, cost: 10, level: 1, exp: 0, unloadTime: 1.5, spritePrefix: 'k', spriteNumber: 1 },
    { id: 2, name: "Prosty Kret", icon: "🐹", mining: 2, speed: 1.05, strength: 1, cost: 20, level: 1, exp: 0, unloadTime: 1.2, spritePrefix: 'k', spriteNumber: 2 },
    { id: 3, name: "Ślepy Kret", icon: "🐁", mining: 3, speed: 1.1, strength: 1, cost: 40, level: 1, exp: 0, unloadTime: 1, spritePrefix: 'k', spriteNumber: 3 }
  ];
  const defaultToolsData = [
    { id: 1, name: "Łopata +1", icon: "⛏️", bonus: 1, cost: 50 },
    { id: 2, name: "Młotek +1", icon: "🔨", bonus: 2, cost: 120 },
    { id: 3, name: "Śrubokręt", icon: "🪛", bonus: 3, cost: 250 }
  ];

  let heroesData = [];
  let toolsData = [];
  let playerDiamonds = 0;
  const maxTeamSize = 12;
  const corridors = Array(maxTeamSize).fill(0).map(() => ({
    wallHP: 10000 + Math.floor(Math.random() * 90000),
    maxDiamonds: 100,
    remainingDiamonds: 100,
    wallStart: 0.1, // ściana zaczyna się na 10% szerokości korytarza
    bucketCapacity: 100, // pojemność wiadra na diamenty
    bucketAmount: 0 // aktualna ilość w wiadrze
  }));
  // tablica bohaterów
  let team = new Array(maxTeamSize).fill(null);
  let miningBoostMultiplier = 1;
  let equippedTools = [];

  const playerDiamondsSpan = document.getElementById("player-diamonds");
  const teamContainer = document.getElementById("team");
  const btnMine = document.getElementById("btn-mine");
  const heroesList = document.getElementById("heroes-list");
  const toolsList = document.getElementById("tools-list");
  const btnReset = document.getElementById("btn-reset");
  const popup = document.getElementById("popup");
  const popupTitle = document.getElementById("popup-title");
  const popupDesc = document.getElementById("popup-desc");
  const popupAction = document.getElementById("popup-action");
  const popupClose = document.getElementById("popup-close");

  // Animacja diamentu wyłączona

  // Zapewnij kontekst pozycjonowania dla sprite’ów
  teamContainer.style.position = "relative";

  async function loadJSON(url, fallback) {
    try {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`Błąd ładowania ${url}`);
      return await res.json();
    } catch (e) {
      console.warn(e.message);
      return fallback;
    }
  }

  let namesData = { przymiotniki: [], zdrobnienia_imion: [] };

  async function loadNames() {
    try {
      const res = await fetch("names.json");
      if (!res.ok) throw new Error("Błąd ładowania names.json");
      namesData = await res.json();
    } catch (e) {
      namesData = { przymiotniki: ["Zwinny"], zdrobnienia_imion: ["Krecik"] };
    }
  }

  function generateHeroName() {
    const adj = namesData.przymiotniki;
    const im = namesData.zdrobnienia_imion;
    if (!adj.length || !im.length) return "Bezimienny Kret";
    const przym = adj[Math.floor(Math.random() * adj.length)];
    const name = im[Math.floor(Math.random() * im.length)];
    return `${przym} ${name}`;
  }

  function createHeroInstance(base) {
    // Jeśli base ma już instanceName, zachowaj je
    return {
      ...JSON.parse(JSON.stringify(base)),
      instanceName: base.instanceName || generateHeroName(),
      currentLoad: 0,
      position: 0,
      state: "commuting",
      miningProgress: 0,
      unloadTimer: 0,
      justMined: 0,
      _emittedUnloadFx: false // flaga: sprite tylko raz na rozładunek
    };
  }

  function createWindziarzInstance(base) {
    return {
      ...JSON.parse(JSON.stringify(base)),
      position: -0.5, // korytarz index
      target: 0,
      state: "idle", // idle, moving, loading, returning, unloading
      carried: 0,
      loadingTimer: 0,
      exp: base.exp || 0,
      level: base.level || 1,
      capacity: base.capacity || 1000,
      loadingspeed: base.loadingspeed || 50,
      _spriteAcc: 0,
      _spriteTimer: 0
    };
  }

  /**
   * Asynchronicznie pobiera i wycina bitmapę bohatera z arkusza spritów.
   *
   * @param {string} prefix Prefiks nazwy pliku (np. "k").
   * @param {number} heroNumber Numer bohatera (liczony od 1).
   * @returns {Promise<ImageBitmap|null>} Obietnica, która zwraca obiekt ImageBitmap
   * lub null, jeśli wystąpił błąd
   * (np. zły numer, brak pliku).
   */
  async function getHeroBitmap(prefix, heroNumber) {
    // --- 1. Walidacja danych wejściowych ---
    if (!prefix || typeof prefix !== 'string' || typeof heroNumber !== 'number' || heroNumber <= 0) {
      console.error("Błędne parametry wejściowe.");
      return null;
    }

    // --- 2. Obliczenia pliku i pozycji sprita ---
    const SPRITES_PER_ROW = 5;
    const SPRITES_PER_COLUMN = 4;
    const SPRITES_PER_FILE = SPRITES_PER_ROW * SPRITES_PER_COLUMN; // 20 spritów na plik
    const SPRITE_SIZE = 128; // Rozmiar pojedynczego sprita w px

    // Oblicz, w którym pliku znajduje się bohater
    // Np. bohater 1-20 -> plik 1; bohater 21-40 -> plik 2
    const fileNumber = Math.ceil(heroNumber / SPRITES_PER_FILE);
    const imagePath = `images/${prefix}${fileNumber}.png`;

    // Oblicz pozycję (indeks) bohatera w jego pliku (od 0 do 19)
    const indexInFile = (heroNumber - 1) % SPRITES_PER_FILE;

    // Oblicz współrzędne (x, y) sprita w siatce na arkuszu
    const sx = (indexInFile % SPRITES_PER_ROW) * SPRITE_SIZE;
    const sy = Math.floor(indexInFile / SPRITES_PER_ROW) * SPRITE_SIZE;

    // --- 3. Wczytanie obrazu i wycięcie bitmapy ---
    try {
      // Stwórz nowy obiekt obrazu w pamięci
      const image = new Image();
      image.src = imagePath;

      // Poczekaj na załadowanie obrazu. Jeśli ścieżka jest zła, .onerror odrzuci Promise.
      await image.decode(); // Nowocześniejsza i bardziej niezawodna alternatywa dla image.onload

      // Wytnij odpowiedni fragment z wczytanego obrazu i stwórz z niego bitmapę
      // To podejście jest wydajniejsze niż rysowanie na dodatkowym canvasie.
      const bitmap = await createImageBitmap(image, sx, sy, SPRITE_SIZE, SPRITE_SIZE);

      return bitmap;
    } catch (error) {
      // Błąd wystąpi, jeśli plik obrazu nie zostanie znaleziony (błąd 404) lub jest uszkodzony.
      console.error(`Nie udało się wczytać pliku: ${imagePath}`, error);
      return null;
    }
  }

  function updateDiamondsDisplay() {
    playerDiamondsSpan.textContent = `💎 Diamenty: ${formatNumber(playerDiamonds)}`;
    checkElevatorEnabled();
  }

  // --- Diamond transfer animation framework ---
  const DIAMOND_SPRITE_MAX = 30; // Zwiększamy limit, bo animacje są teraz lżejsze
  let _activeDiamondSprites = 0;

  // spawn n sprites (capped) from startRect to endRect; doesn't affect scroll (position:fixed)
  function spawnDiamondSprites(startRect, endRect, n, durationOverride, onDiamondReach) {
    if (!startRect || !endRect || n <= 0) return;
    
    const toSpawn = Math.min(Math.round(n), DIAMOND_SPRITE_MAX - _activeDiamondSprites);
    if (toSpawn <= 0) return;

    const diamondsPerSprite = n / toSpawn;
    const totalDuration = (typeof durationOverride === 'number' && durationOverride > 0) ? durationOverride : 700;
    const flyTime = 700; // Stały czas lotu pojedynczego diamentu w ms.

    // Okno czasowe, w którym muszą wystartować wszystkie diamenty, aby ostatni wylądował po upływie totalDuration
    const launchWindow = Math.max(0, totalDuration - flyTime);

    for (let k = 0; k < toSpawn; k++) {
      _activeDiamondSprites++;
      const el = document.createElement('div');
      el.className = 'diamond-sprite';
      el.textContent = '💎';
      
      const sx = startRect.left + startRect.width / 2;
      const sy = startRect.top + startRect.height / 2;
      const ex = endRect.left + endRect.width / 2;
      const ey = endRect.top + endRect.height / 2;

      el.style.position = 'fixed';
      el.style.left = sx + 'px';
      el.style.top = sy + 'px';
      el.style.zIndex = '14000';
      el.style.pointerEvents = 'none';

      el.style.setProperty('--dx', `${ex - sx}px`);
      el.style.setProperty('--dy', `${ey - sy}px`);
      
      el.style.animationDuration = `${flyTime}ms`;
      
      // Rozłóż starty równomiernie w oknie startowym.
      // Jeśli toSpawn = 1, opóźnienie wyniesie 0.
      const delay = (toSpawn > 1) ? (k / (toSpawn - 1)) * launchWindow : 0;
      el.style.animationDelay = `${delay}ms`;

      document.body.appendChild(el);

      el.addEventListener('animationend', () => {
        el.remove();
        _activeDiamondSprites = Math.max(0, _activeDiamondSprites - 1);
        if (typeof onDiamondReach === 'function') {
          onDiamondReach(diamondsPerSprite);
        }
      });
    }
  }

  // helper: spawn sprites given corridor index by locating hero (round) and bucket bar elements in DOM
  function animateTransferInCorridor(corridorIndex, amount, durationMs) {
    try {
      const corridorEl = teamContainer.querySelector(`[data-corridor-index="${corridorIndex}"]`);
      if (!corridorEl) return;
      // use the round hero position as the start (reliable visual) and the bucket bar as the end
      const heroPosEl = corridorEl.querySelector('.hero-position');
      const bucketBarEl = corridorEl.querySelector('.bucket .bucket-bar');
      // fall back to previous elements if these are missing
      const heroEl = heroPosEl || corridorEl.querySelector('.hero-info .hero-icon');
      const bucketEl = bucketBarEl || corridorEl.querySelector('.bucket .bucket-icon') || corridorEl.querySelector('.bucket');
      if (!heroEl || !bucketEl) return;
      const heroRect = heroEl.getBoundingClientRect();
      const bucketRect = bucketEl.getBoundingClientRect();
      console.debug('animateTransferInCorridor', { corridorIndex, amount, durationMs, heroRect, bucketRect, heroEl, bucketEl });
      
      const corridor = corridors[corridorIndex];
      const onDiamondReach = (value) => {
        if (corridor) {
          const cap = corridor.bucketCapacity || 100;
          const space = Math.max(0, cap - (corridor.bucketAmount || 0));
          const transfer = Math.min(value, space);
          corridor.bucketAmount = (corridor.bucketAmount || 0) + transfer;
        }
      };
      spawnDiamondSprites(heroRect, bucketRect, amount, durationMs, onDiamondReach);
    } catch (e) { console.warn('animateTransfer err', e); }
  }
  // --- end animation framework ---

  function renderTeam() {
    teamContainer.innerHTML = "";
    for (let i = 0; i < maxTeamSize; i++) {
      const corridor = corridors[i];
      const hero = team[i];
      const maxWallHP = corridor.wallHP + 2000;

      const corridorEl = document.createElement("section");
      corridorEl.className = "corridor";
      corridorEl.dataset.corridorIndex = i;
      corridorEl.setAttribute("role", "listitem");
      corridorEl.setAttribute("aria-label", hero ? `Korytarz z bohaterem ${hero.name}` : "Wolny korytarz");
      corridorEl.style.position = "relative";



      if (i > 0) {
        const destroyBtn = document.createElement('button');
        destroyBtn.textContent = '💥';
        destroyBtn.title = 'Zburz korytarz';
        destroyBtn.style.position = 'absolute';
        destroyBtn.style.top = '2px';
        destroyBtn.style.right = '5px';
        destroyBtn.style.zIndex = '10';
        destroyBtn.style.background = 'none';
        destroyBtn.style.border = 'none';
        destroyBtn.style.fontSize = '1.2rem';
        destroyBtn.style.cursor = 'pointer';
        destroyBtn.style.padding = '0';
        destroyBtn.onclick = (e) => {
          e.stopPropagation();
          destroyCorridor(i);
        };
        corridorEl.appendChild(destroyBtn);
      }

           
      const heroInfo = document.createElement("div");
      heroInfo.className = "hero-info";
      if (hero) {
        heroInfo.style.cursor = "pointer";
        // Przekazujemy do popupu konkretną instancję bohatera i jego indeks
        heroInfo.onclick = () => showHeroPopup(hero, i);
 // Dodaj obwolutę
 const heroFrame = document.createElement('div');
  heroFrame.className = `hero-frame hero-level-${Math.min(10, hero.level)}`;

        const icon = document.createElement("div");
        icon.className = "hero-icon";

        if (typeof hero.spriteNumber === 'number') {
          icon.textContent = hero.icon; // Fallback na czas ładowania
          (async () => {
            const bitmap = await getHeroBitmap('k', hero.spriteNumber);
            if (bitmap && icon.isConnected) {
              const canvas = document.createElement('canvas');
              // Dopasuj rozmiar canvasa do stylu .hero-icon
              canvas.style.width = "100%";
              canvas.style.height = "100%";
              canvas.style.objectFit = "cover";
              const ctx = canvas.getContext('2d');
              ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
              icon.innerHTML = ''; // Wyczyść fallback
              icon.appendChild(canvas);
            }
          })();
        } else if (hero.image) {
          const img = document.createElement("img");
          img.src = `images/${hero.image}`;
          img.alt = hero.name;
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "cover";
          img.onerror = () => {
            img.remove();
            icon.textContent = hero.icon;
          };
          icon.appendChild(img);
        } else {
          icon.textContent = hero.icon;
        }
        const nameContainer = document.createElement("div");
        nameContainer.className = "hero-name-container";
        const heroInstanceName = document.createElement("div");
        heroInstanceName.className = "hero-instance-name";
        heroInstanceName.textContent = hero.instanceName;
        nameContainer.appendChild(heroInstanceName);
        const heroClassName = document.createElement("div");
        heroClassName.className = "hero-class-name";
        heroClassName.textContent = hero.name;
        nameContainer.appendChild(heroClassName);
        heroInfo.appendChild(icon);
        heroInfo.appendChild(nameContainer);
        heroInfo.appendChild(heroFrame);
      } else {
        heroInfo.textContent = "(wolny korytarz)";
        heroInfo.style.justifyContent = "center";
        heroInfo.style.color = "#999";
      }
      corridorEl.appendChild(heroInfo);

      if (i > 0) {
        // wiadro na diamenty między bohaterem a korytarzem
        const bucketEl = document.createElement('div');
        bucketEl.className = 'bucket';
        const bIcon = document.createElement('div'); bIcon.className = 'bucket-icon'; bIcon.textContent = '🪣';
        const bCap = document.createElement('div'); bCap.className = 'bucket-cap'; bCap.textContent = `${formatNumber(corridor.bucketAmount || 0)}/${formatNumber(corridor.bucketCapacity || 100)}`;
        const bBar = document.createElement('div'); bBar.className = 'bucket-bar';
        const bFill = document.createElement('div'); bFill.className = 'bucket-fill';
        const fillPct = Math.round(((corridor.bucketAmount || 0) / (corridor.bucketCapacity || 1)) * 100);
        bFill.style.width = `${fillPct}%`;
        bBar.appendChild(bFill);
        bucketEl.appendChild(bIcon);
        bucketEl.appendChild(bBar);
        bucketEl.appendChild(bCap);
        // tooltip + lepsze zachowanie kliknięcia
        bucketEl.title = 'Opróżnij wiadro (klik)';
        bucketEl.style.padding = '4px 6px';
        // upewnij się, że ikona nie blokuje kliknięcia
        bIcon.style.pointerEvents = 'none';
        bucketEl.addEventListener('click', (e) => {
          e.stopPropagation();
          e.preventDefault();
          const amt = corridor.bucketAmount || 0;
          if (amt <= 0) return;
          playerDiamonds += amt;
          corridor.bucketAmount = 0;
          updateDiamondsDisplay();
          saveGame();
          renderTeam();
        });
        corridorEl.appendChild(bucketEl);
      } else {
        const storageArea = document.createElement('div');
        storageArea.id = 'storage-area';
        storageArea.textContent = 'Miejsce składowania';
        storageArea.style.textAlign = 'center';
        storageArea.style.padding = '10px';
        storageArea.style.color = '#ccc';
        storageArea.style.width = '100%';
        corridorEl.appendChild(storageArea);
      }

      const wall = document.createElement("div");
      wall.className = "wall";
      const wallFill = document.createElement("div");
      wallFill.className = "wall-fill";
      // renderowanie przesuwającej się ściany opartej na remainingDiamonds
      const maxD = corridor.maxDiamonds || 100;
      const remD = Math.max(0, Math.min(maxD, corridor.remainingDiamonds ?? maxD));
      const leftRatio = (corridor.wallStart || 0.1) + (1 - remD / maxD) * (1 - (corridor.wallStart || 0.1));
      const leftPct = (leftRatio * 100).toFixed(3);
      const widthPct = Math.max(0, ((1 - leftRatio) * 100).toFixed(3));
      wallFill.style.position = 'absolute';
      wallFill.style.left = leftPct + '%';
      wallFill.style.width = widthPct + '%';
      // etykieta pokazująca pozostałe diamenty - umieszczona wewnątrz niebieskiej części (.wall-fill)
      const wallLabel = document.createElement('div');
      wallLabel.className = 'wall-label';
      wallLabel.textContent = `${formatNumber(remD)}/${formatNumber(maxD)}`;
      // ustawienie wewnątrz .wall-fill, wyrównane do prawej krawędzi fill (mały offset)
      wallLabel.style.right = '6px';
      wallLabel.style.left = 'auto';
      wallLabel.style.transform = 'translateY(-50%)';
      wallLabel.style.pointerEvents = 'none';
      wallFill.appendChild(wallLabel);
      wall.appendChild(wallFill);

      if (hero) {
        const heroPos = document.createElement("div");
        heroPos.className = "hero-position";
        heroPos.style.overflow = "hidden";
        heroPos.style.display = "flex";
        heroPos.style.alignItems = "center";
        heroPos.style.justifyContent = "center";
        heroPos.style.fontSize = "1rem";

        const icon = document.createElement("div");
        icon.textContent = hero.icon;
        icon.style.userSelect = "none";
        icon.style.transform = "scale(1.5)";
        icon.style.lineHeight = "1";
        icon.style.pointerEvents = "none";

        // kolory dla poszczególnych faz
        const stateColors = { commuting: '#ffd166', mining: '#06d6a0', transporting: '#118ab2', unloading: '#ef476f', idle: '#9ca3af' };
        const stateBorders = { commuting: '#b58300', mining: '#0aa372', transporting: '#095a80', unloading: '#c11237', idle: '#6b7280' };
        const bg = stateColors[hero.state] || '#ffffff';
        const bd = stateBorders[hero.state] || '#0c80a6';
        heroPos.style.background = bg;
        heroPos.style.borderColor = bd;
        // kontrast dla ikony (żółty -> ciemny, pozostałe -> biały)
        icon.style.color = (hero.state === 'commuting' || hero.state === 'idle') ? '#121212' : '#ffffff';

        heroPos.appendChild(icon);

        if (hero.state === "unloading" || hero.state === "idle") {
          // idle i unloading stoją na początku kopalni
          heroPos.style.left = "0%";
          heroPos.classList.add("unloading");
        } else {
          heroPos.classList.remove("unloading");
          let progressRatio = 0;
          if (hero.state === "commuting") progressRatio = Math.min(1, hero.position / 100);
          else if (hero.state === "mining") progressRatio = leftRatio; // podczas kopania stoi przy ścianie
          else if (hero.state === "transporting") progressRatio = Math.min(1, hero.position / 100);
          heroPos.style.left = `${progressRatio * 100}%`;
        }

        wall.appendChild(heroPos);
      }
      corridorEl.appendChild(wall);

      const progressBarContainer = document.createElement("div");
      progressBarContainer.className = "progress-container";
      corridorEl.appendChild(progressBarContainer);

      const progressBarFill = document.createElement("div");
      progressBarFill.className = "progress-fill";
      progressBarFill.style.width = "0%";
      progressBarContainer.appendChild(progressBarFill);

      if (hero && hero.state === "mining") {
        // używamy currentLoad/strength aby pasek postępu był płynny
        const percent = Math.min(100, ((hero.currentLoad || 0) / (hero.strength || 1)) * 100);
        progressBarFill.style.width = `${percent}%`;
      }

      teamContainer.appendChild(corridorEl);
    }
    renderElevator();
  }

  function renderElevator() {
    let elevatorEl = document.getElementById("elevator");
    const shouldShowElevator = elevatorEnabled || windziarzTeam.length > 0;
    const appEl = document.getElementById("app");
    if (!elevatorEl) {
      elevatorEl = document.createElement("div");
      elevatorEl.id = "elevator";
      elevatorEl.style.position = "absolute";
      elevatorEl.style.width = "48px";
      elevatorEl.style.background = "linear-gradient(to bottom, #444 80%, #222 100%)";
      elevatorEl.style.borderRadius = "18px";
      elevatorEl.style.border = "2px solid #666";
      elevatorEl.style.display = shouldShowElevator ? "flex" : "none";
      elevatorEl.style.flexDirection = "column";
      elevatorEl.style.alignItems = "center";
      elevatorEl.style.justifyContent = "flex-start";
      elevatorEl.style.zIndex = "9000";
      elevatorEl.style.boxShadow = "2px 0 8px #000a";
      appEl.insertBefore(elevatorEl, document.getElementById("team"));
    }
    // layout and visibility each call
    appEl.classList.toggle("with-elevator", shouldShowElevator);
    elevatorEl.style.display = shouldShowElevator ? "flex" : "none";
    elevatorEl.style.left = "8px";
    elevatorEl.style.top = teamContainer.offsetTop + "px";
    elevatorEl.style.height = teamContainer.offsetHeight + "px";
    
    if (shouldShowElevator) {
      windziarzTeam.forEach((wz) => {
        let wzNode = document.getElementById(`windziarz-${wz.id}`);
        if (!wzNode) {
          elevatorEl.innerHTML = ''; // Wyczyść starych windziarzy przy tworzeniu nowego
          wzNode = document.createElement("div");
          wzNode.id = `windziarz-${wz.id}`;
          wzNode.className = "windziarz-pos";
          wzNode.style.margin = "8px 0";
          wzNode.style.fontSize = "2rem";
          wzNode.style.position = "absolute";
          wzNode.style.left = "50%";
          wzNode.style.transform = "translateX(-50%)";
          wzNode.style.cursor = "pointer";
          wzNode.onclick = () => showWindziarzPopup(wz);

          const wzIcon = document.createElement("div");
          wzIcon.className = "wz-icon";

          if (wz.image) {
              const img = document.createElement("img");
              img.src = `images/${wz.image}`;
              img.alt = wz.name;
              img.style.width = "100%";
              img.style.height = "100%";
              img.style.objectFit = "cover";
              img.onerror = () => {
                  img.remove();
                  wzIcon.textContent = wz.icon;
              };
              wzIcon.appendChild(img);
          } else {
              wzIcon.textContent = wz.icon;
          }
          wzNode.appendChild(wzIcon);

          const loadingBar = document.createElement("div");
          loadingBar.className = "loading-bar";
          const loadingFill = document.createElement("div");
          loadingFill.className = "loading-fill";
          loadingBar.appendChild(loadingFill);
          wzNode.appendChild(loadingBar);
          elevatorEl.appendChild(wzNode);
        }

        // Aktualizuj pozycję i pasek ładowania
        wzNode.style.top = ((wz.position / maxTeamSize) * teamContainer.offsetHeight) + 12 + "px";
        
        const loadingBar = wzNode.querySelector('.loading-bar');
        const loadingFill = wzNode.querySelector('.loading-fill');
        if (wz.carried > 0) {
          const fillPercentage = (wz.carried / (wz.capacity || 1000)) * 100;
          loadingFill.style.width = `${fillPercentage}%`;
          loadingBar.style.display = 'block';
        } else {
          loadingBar.style.display = 'none';
        }
      });
    } else {
      elevatorEl.innerHTML = "";
    }
  }

  function showHeroPopup(hero, corridorIndex = null) {
    const isUpgrade = corridorIndex !== null;
    const heroData = isUpgrade ? hero : heroesData.find(h => h.id === hero.id);
    if (!heroData) return;

    const cost = isUpgrade ? (heroData.cost || hero.cost) : heroData.cost;

    popupTitle.textContent = heroData.name + (isUpgrade ? ` (Poziom ${heroData.level})` : '');
    popupDesc.innerHTML = `
      <div class="stat">Siła kopania: <b>${heroData.mining}</b></div>
      <div class="stat">Prędkość: <b>${heroData.speed.toFixed(2)}</b></div>
      <div class="stat">Wytrzymałość: <b>${heroData.strength}</b></div>
      ${isUpgrade ? `<div class="stat">Doświadczenie: <b>${heroData.exp}</b></div>` : ''}
      <div class="stat">Czas rozładunku: <b>${(heroData.unloadTime || (5 / heroData.strength)).toFixed(2)}s</b></div>
      <hr>
      <div class="stat">Koszt ${isUpgrade ? 'ulepszenia' : 'zakupu'}: <b>💎 ${formatNumber(cost)}</b></div>
    `;
    popupAction.style.display = "block";
    popupAction.textContent = isUpgrade ? "Ulepsz" : "Kup";

    popupAction.onclick = () => {
      if (playerDiamonds < cost) {
        alert("Za mało diamentów.");
        return;
      }
      playerDiamonds -= cost;

      if (isUpgrade) {
        // Logika ulepszania istniejącego bohatera
        const heroToUpgrade = team[corridorIndex];
        heroToUpgrade.level++;
        heroToUpgrade.mining = Math.floor(heroToUpgrade.mining * 1.1 + 1);
        heroToUpgrade.strength = Math.floor(heroToUpgrade.strength * 1.1 + 1);
        heroToUpgrade.speed *= 1.03;
        heroToUpgrade.cost = Math.floor(cost * 1.15); // Koszt ulepszenia rośnie dla tej instancji
      } else {
        // Logika kupowania nowego bohatera
        let freeSlotIndex = -1;
        for (let i = 1; i < maxTeamSize; i++) {
          if (team[i] === null) {
            freeSlotIndex = i;
            break;
          }
        }
        
        if (freeSlotIndex === -1) {
          alert("Brak wolnych korytarzy na nowego bohatera.");
          playerDiamonds += cost; // Zwróć diamenty
          return;
        }
        const newHeroInstance = createHeroInstance(heroData);
        team[freeSlotIndex] = newHeroInstance;
        // Zwiększ koszt zakupu w sklepie dla tego typu bohatera
        heroData.cost = Math.floor(cost * 1.15);
      }

      updateDiamondsDisplay();
      saveGame();
      popup.style.display = "none";
      renderHeroesShop();
      renderTeam();
    };

    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function createNewCorridor() {
    return {
      wallHP: 10000 + Math.floor(Math.random() * 90000),
      maxDiamonds: getRandomDiamonds(),
      remainingDiamonds: getRandomDiamonds(),
      wallStart: 0.1,
      bucketCapacity: 100,
      bucketAmount: 0
    };
  }

  function destroyCorridor(index) {
    if (index <= 0 || index >= maxTeamSize) return;
    if (confirm('Czy na pewno chcesz zburzyć ten korytarz? Bohater i diamenty w wiadrze zostaną utracone!')) {
      team.splice(index, 1);
      corridors.splice(index, 1);

      team.push(null);
      corridors.push(createNewCorridor());

      saveGame();
      renderTeam();
    }
  }

  function showWindziarzPopup(wz) {
    popupTitle.textContent = wz.name;
    popupDesc.innerHTML = `
      <div class="stat">Poziom: <b>${wz.level}</b></div>
      <div class="stat">Doświadczenie: <b>${wz.exp}</b></div>
      <div class="stat">Prędkość: <b>${(wz.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Siła: <b>${wz.strength}</b></div>
      <div class="stat">Pojemność: <b>${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Załadunek: <b>${formatNumber(wz.carried)} / ${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Szybkość ładowania: <b>${wz.loadingspeed} d/s</b></div>
    `;
    popupAction.style.display = "none";
    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  function showWindziarzPurchasePopup(wz) {
    popupTitle.textContent = wz.name;
    popupDesc.innerHTML = `
      <div class="stat">Prędkość: <b>${(wz.speed || 1).toFixed(2)}</b></div>
      <div class="stat">Pojemność: <b>${formatNumber(wz.capacity)}</b></div>
      <div class="stat">Szybkość ładowania: <b>${wz.loadingspeed} d/s</b></div>
      <hr>
      <div class="stat">Koszt: <b>💎 ${formatNumber(wz.cost)}</b></div>
    `;
    popupAction.style.display = "block";
    popupAction.textContent = "Kup";

    popupAction.onclick = () => {
      if (playerDiamonds < wz.cost) {
        alert("Za mało diamentów na zakup windziarza.");
        return;
      }
      
      playerDiamonds -= wz.cost;
      windziarzTeam = [createWindziarzInstance(wz)];
      windziarzPurchased = true;
      updateDiamondsDisplay();
      saveGame();
      popup.style.display = "none";
      renderWindziarzeShop();
      renderElevator();
    };

    popup.style.display = "flex";
    popup.setAttribute("aria-hidden", "false");
    popup.querySelector("#popup-content").focus();
  }

  popupClose.onclick = () => {
    popup.style.display = "none";
  };
  popup.addEventListener("click", e => {
    if (e.target === popup) popup.style.display = "none";
  });

  function renderHeroesShop() {
    heroesList.innerHTML = "";
    for (const heroBase of heroesData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = heroBase.name;

      const icon = document.createElement("div");
      icon.className = "shop-icon";
      icon.textContent = heroBase.icon;
      item.appendChild(icon);

      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = heroBase.name;
      item.appendChild(name);

      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `💎 ${formatNumber(heroBase.cost)}`;
      item.appendChild(cost);

      item.onclick = () => {
        // Wywołujemy popup bez indeksu, co oznacza "kupowanie"
        showHeroPopup(heroBase);
      };

      heroesList.appendChild(item);
    }
  }

  function renderToolsShop() {
    toolsList.innerHTML = "";
    for (const tool of toolsData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = tool.name;

      const icon = document.createElement("div");
      icon.className = "shop-icon";
      icon.textContent = tool.icon || "🧰";
      item.appendChild(icon);

      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = tool.name;
      item.appendChild(name);

      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `💎 ${formatNumber(tool.cost)}`;
      item.appendChild(cost);

      item.onclick = () => {
        if (playerDiamonds < tool.cost) {
          alert("Za mało diamentów na zakup.");
          return;
        }
        if (equippedTools.find(t => t.name === tool.name)) {
          alert("Już masz to narzędzie.");
          return;
        }
        playerDiamonds -= tool.cost;
        updateDiamondsDisplay();
        equippedTools.push({ ...tool, durability: 100 });
        updateMiningBoost();
        renderToolsShop();
        saveGame();
      };

      toolsList.appendChild(item);
    }
  }

  function gameLoopStep(dt) {
    let diamondsGained = 0;
    for (let i = 0; i < maxTeamSize; i++) {
      const hero = team[i];
      if (!hero) continue;
      const corridor = corridors[i];
      const DIST = 100;
      const speed = hero.speed * dt * 50;

      switch (hero.state) {
        case "commuting":
          hero.position = Math.min(DIST, hero.position + speed);
          // oblicz pozycję ściany (w tej samej skali co hero.position [0..100])
          const maxD2 = corridor.maxDiamonds || 100;
          const remD2 = Math.max(0, Math.min(maxD2, corridor.remainingDiamonds ?? maxD2));
          const leftRatio2 = (corridor.wallStart || 0.1) + (1 - remD2 / maxD2) * (1 - (corridor.wallStart || 0.1));
          const targetPos = leftRatio2 * DIST;
          if (hero.position >= targetPos) {
            hero.state = "mining";
            hero.miningProgress = 0;
            hero.currentLoad = 0;
            hero.justMined = 0;
            // ustaw pozycję bohatera dokładnie przy ścianie
            hero.position = targetPos;
          }
          break;
        case "mining":
          // odejmuj ilość wykopaną w tej klatce (płynnie)
          const minedFloat = hero.mining * miningBoostMultiplier * dt;
          // inkrementuj wewnętrzny licznik (opcjonalnie - do innych mechanik)
          hero.miningProgress = (hero.miningProgress || 0) + minedFloat;
          const actualMined = Math.min(minedFloat, corridor.remainingDiamonds || 0);
          corridor.remainingDiamonds = Math.max(0, (corridor.remainingDiamonds || 0) - actualMined);
          hero.currentLoad += actualMined;
          hero.justMined = actualMined;

          const durabilityLoss = actualMined * 0.1;
          equippedTools.forEach(t => (t.durability = Math.max(0, t.durability - durabilityLoss)));
          equippedTools = equippedTools.filter(t => t.durability > 0);
          renderToolsShop();

          if (hero.currentLoad >= hero.strength || (corridor.remainingDiamonds || 0) <= 0) {
            hero.state = "transporting";
            // rozpoczynaj transport z pozycji ściany (obliczonej na podstawie remainingDiamonds)
            const maxD3 = corridor.maxDiamonds || 100;
            const remD3 = Math.max(0, Math.min(maxD3, corridor.remainingDiamonds ?? maxD3));
            const leftRatio3 = (corridor.wallStart || 0.1) + (1 - remD3 / maxD3) * (1 - (corridor.wallStart || 0.1));
            hero.position = Math.round(leftRatio3 * DIST);
          }
          break;
        case "transporting":
          hero.position = Math.max(0, hero.position - speed);
          if (hero.position <= 0) {
            hero.state = "unloading";
            // ustaw czas rozładunku i zainicjuj wewnętrzne liczniki transferu
            const ut = (typeof hero.unloadTime === "number") ? hero.unloadTime : 5 / (hero.strength || 1);
            // FIX: Czas rozładunku proporcjonalny do ładunku, aby utrzymać stałą szybkość
            const fullLoadAmount = hero.strength || 1;
            const currentLoad = hero.currentLoad || 0;
            const timeForLoad = ut * (currentLoad / Math.max(1, fullLoadAmount));
            // store in seconds for timers
            hero.unloadTimer = timeForLoad;
            hero._unloadInitial = timeForLoad;
            // amount that should be transferred from hero to bucket during unloading
            hero._unloadRemaining = currentLoad;
            
            // Wyczyść ładunek bohatera, bo diamenty są teraz w "locie"
            const amountToAnimate = hero.currentLoad;
            hero.currentLoad = 0;

            if (amountToAnimate > 0) {
              const durMs = (hero.unloadTimer || 1) * 1000;
              animateTransferInCorridor(i, amountToAnimate, durMs);
            }
          }
          break;
        case "unloading":
          // Odejmuj czas od timera
          if (hero.unloadTimer > 0) {
            hero.unloadTimer -= dt;
          }

          // Gdy timer dobiegnie końca, zdecyduj co dalej
          if (hero.unloadTimer <= 0) {
            // Sprawdź, czy w korytarzu są jeszcze diamenty do wykopania
            if ((corridor.remainingDiamonds || 0) > 0) {
              // Jeśli tak, wróć do pracy
              hero.state = 'commuting';
            } else {
              // Jeśli nie, przejdź w stan bezczynności
              hero.state = 'idle';
            }
            hero.position = 0;
            // Wyczyszczenie starych danych o rozładunku
            hero._unloadInitial = undefined;
            hero._unloadRemaining = undefined;
          }
          break;
        case "idle":
          const bucketHasSpace = (corridor.bucketAmount || 0) < (corridor.bucketCapacity || 100);
          if (bucketHasSpace && (hero.currentLoad || 0) > 0) {
            hero.state = "unloading";
            const ut = (typeof hero.unloadTime === "number") ? hero.unloadTime : 5 / (hero.strength || 1);
            // FIX: Wznów rozładunek z proporcjonalnym czasem dla reszty ładunku
            const fullLoadAmount = hero.strength || 1;
            const remainingLoad = hero.currentLoad || 0;
            const timeForRemaining = ut * (remainingLoad / Math.max(1, fullLoadAmount));
            hero.unloadTimer = timeForRemaining;
            hero._unloadInitial = timeForRemaining;
            hero._unloadRemaining = hero.currentLoad || 0;
            // Wznów także animację dla pozostałych diamentów
            const totalVisual = Math.min(Math.max(0, Math.round(hero._unloadRemaining || 0)), DIAMOND_SPRITE_MAX);
            if (totalVisual > 0) {
              const durMs = (hero.unloadTimer || 1) * 1000;
              animateTransferInCorridor(i, totalVisual, durMs);
            }
          } else if (corridor.remainingDiamonds > 0 && bucketHasSpace) {
            hero.state = "commuting";
          }
          break;
      }
      if (hero.state !== "idle" && corridor.remainingDiamonds <= 0 && hero.currentLoad === 0) {
        hero.state = "idle";
      }
    }
    if (diamondsGained > 0) {
      team.forEach(hero => {
        if (!hero) return;
        if (hero.currentLoad === 0 && hero.state === "commuting") {
          hero.exp = (hero.exp || 0) + 2;
          if (hero.exp >= 100) {
            hero.level = (hero.level || 1) + 1;
            hero.exp -= 100;
            hero.mining = Math.floor(hero.mining * 1.1 + 1);
            hero.strength = Math.floor(hero.strength * 1.1 + 1);
            hero.speed *= 1.03;
          }
        }
      });
      saveGame();
    }
    // rendering jest teraz dławiony w głównej pętli, aby nie niszczyć elementów klikalnych co klatkę
    windziarzGameLoop(dt);
  }

  function updateMiningBoost() {
    miningBoostMultiplier = equippedTools.reduce((acc, t) => acc * (t.bonus || 1), 1);
  }

  function saveGame() {
    try {
      const state = { playerDiamonds, team, corridors, equippedTools, windziarzTeam, windziarzPurchased };
      localStorage.setItem("diamondMineGameState", JSON.stringify(state));
    } catch (e) {
      console.warn("Błąd zapisu stanu gry", e);
    }
  }

  let windziarzeData = [];
  let windziarzTeam = [];
  let graConfig = { liftAfterCollectionOf: 1000 };
  let elevatorEnabled = false;
  let elevatorDiamonds = 0;
  let windziarzPurchased = false;

  async function loadGraConfig() {
    try {
      const res = await fetch("gra.json");
      if (!res.ok) throw new Error("Błąd ładowania gra.json");
      graConfig = await res.json();
    } catch (e) { graConfig = { liftAfterCollectionOf: 1000 }; }
  }

  async function loadWindziarze() {
    try {
      const res = await fetch("windziarze.json");
      if (!res.ok) throw new Error("Błąd ładowania windziarze.json");
      windziarzeData = await res.json();
    } catch (e) { windziarzeData = []; }
  }

  function checkElevatorEnabled() {
    const shouldBeEnabled = Number(playerDiamonds) >= Number(graConfig.liftAfterCollectionOf) || windziarzPurchased;
    if (shouldBeEnabled && !elevatorEnabled) {
      elevatorEnabled = true;
      const windziarzeShop = document.getElementById("windziarze-shop");
      if (windziarzeShop) {
        windziarzeShop.style.display = "block";
      }
      renderWindziarzeShop();
      renderElevator();
    }
  }

  function renderWindziarzeShop() {
    let shopSection = document.getElementById("windziarze-shop");
    if (!shopSection) {
      shopSection = document.createElement("section");
      shopSection.className = "shop-container";
      shopSection.id = "windziarze-shop";
      shopSection.setAttribute("aria-label", "Sklep windziarzy");
      const title = document.createElement("div");
      title.className = "shop-title";
      title.textContent = "Sklep windziarzy";
      shopSection.appendChild(title);
      const list = document.createElement("div");
      list.className = "shop-list";
      list.id = "windziarze-list";
      list.setAttribute("role", "list");
      shopSection.appendChild(list);
      document.getElementById("app").appendChild(shopSection);
    }
    const windziarzeList = document.getElementById("windziarze-list");
    windziarzeList.innerHTML = "";
    shopSection.style.display = elevatorEnabled ? "block" : "none";
    if (!elevatorEnabled) return;
    for (const wzBase of windziarzeData) {
      const item = document.createElement("div");
      item.className = "shop-item";
      item.title = wzBase.name;
      const icon = document.createElement("div");
      icon.className = "shop-icon";
      if (wzBase.image) {
        const img = document.createElement("img");
        img.src = `images/${wzBase.image}`;
        img.alt = wzBase.name;
        img.style.width = "58px";
        img.style.height = "58px";
        img.style.objectFit = "cover";
        img.onerror = () => {
          img.remove();
          icon.textContent = wzBase.icon;
        };
        icon.appendChild(img);
      } else {
        icon.textContent = wzBase.icon;
      }
      item.appendChild(icon);
      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = wzBase.name;
      item.appendChild(name);
      const cost = document.createElement("div");
      cost.className = "shop-cost";
      cost.textContent = `💎 ${formatNumber(wzBase.cost)}`;
      item.appendChild(cost);
      item.onclick = () => {
        showWindziarzPurchasePopup(wzBase);
      };
      windziarzeList.appendChild(item);
    }
  }

  function windziarzGameLoop(dt) {
    if (!elevatorEnabled) return;
    for (const wz of windziarzTeam) {
      switch (wz.state) {
        case "idle":
          wz.position = 0;
          wz.carried = 0;
          wz.state = "moving";
          wz.target = 0;
          break;
        case "moving":
          if (wz.carried >= (wz.capacity || 1000)) {
            wz.state = "returning";
            wz.target = 0;
            break;
          }
          // szukaj najbliższego wiadra z diamentami od aktualnej pozycji (w dół)
          let found = false;
          for (let idx = Math.round(Math.max(1, wz.position)); idx < maxTeamSize; idx++) {
            if ((corridors[idx].bucketAmount || 0) > 0) {
              wz.target = idx;
              found = true;
              break;
            }
          }
          if (!found) {
            wz.state = "returning";
            wz.target = 0;
            break;
          }
          // płynny ruch windziarza do wybranego wiadra
          if (Math.abs(wz.position - wz.target) > 0.01) {
            wz.position += Math.sign(wz.target - wz.position) * (wz.speed || 1) * dt * 2;
          } else {
            wz.position = wz.target;
            wz.state = "loading";
            
            const corridorEl = teamContainer.querySelector(`[data-corridor-index="${wz.target}"]`);
            const windziarzEl = document.getElementById(`windziarz-${wz.id}`);
            if (corridorEl && windziarzEl) {
                const bucketEl = corridorEl.querySelector('.bucket');
                const corridor = corridors[wz.target];
                if (bucketEl && corridor) {
                    const startRect = bucketEl.getBoundingClientRect();
                    const endRect = windziarzEl.getBoundingClientRect();
                    const amountToLoad = Math.min(corridor.bucketAmount || 0, (wz.capacity || 1000) - (wz.carried || 0));
                    const loadingSpeed = wz.loadingspeed || 50;
                    const duration = (amountToLoad / loadingSpeed); // Czas w sekundach

                    // Ustaw timer na czas trwania ładowania
                    wz.loadingTimer = duration;
                    
                    // Wyczyść wiadro, diamenty są w locie
                    corridor.bucketAmount = Math.max(0, corridor.bucketAmount - amountToLoad);

                    const onDiamondReach = (value) => {
                      wz.carried = (wz.carried || 0) + value;
                    };
                    spawnDiamondSprites(startRect, endRect, amountToLoad, duration * 1000, onDiamondReach);
                }
            }
          }
          break;
        case "loading":
          // Odejmuj czas od timera
          if (wz.loadingTimer > 0) {
            wz.loadingTimer -= dt;
          }

          // Gdy timer dobiegnie końca, zdecyduj co dalej
          if (wz.loadingTimer <= 0) {
            const corridor = corridors[wz.target];
            if (wz.carried >= (wz.capacity || 1000)) {
                wz.state = "returning";
                wz.target = 0;
            } else if ((corridor.bucketAmount || 0) <= 0) {
                // Jeśli wiadro jest puste, a my nie jesteśmy pełni, szukaj dalej
                if (wz.carried < (wz.capacity || 1000) && wz.target < maxTeamSize - 1) {
                  wz.state = "moving";
                  wz.target = wz.target + 1;
                } else {
                  wz.state = "returning";
                  wz.target = 0;
                }
            }
          }
          break;
        case "returning":
          // płynny ruch do góry
          if (wz.position > 0.01) {
            wz.position = Math.max(0, wz.position - (wz.speed || 1) * dt * 2);
          } else {
            wz.position = 0;
            wz.state = "unloading";
            
            const windziarzEl = document.getElementById(`windziarz-${wz.id}`);
            const diamondsDisplayEl = document.getElementById('player-diamonds');
            if (windziarzEl && diamondsDisplayEl && wz.carried > 0) {
                const startRect = windziarzEl.getBoundingClientRect();
                const endRect = diamondsDisplayEl.getBoundingClientRect();
                const unloadSpeed = wz.loadingspeed || 50;
                const amountToUnload = wz.carried;
                const duration = (amountToUnload / unloadSpeed); // Czas w sekundach

                // Ustaw timer na czas trwania rozładunku
                wz.unloadingTimer = duration;

                // Wyzwól animację
                spawnDiamondSprites(startRect, endRect, amountToUnload, duration * 1000, (value) => {
                  playerDiamonds += value;
                  updateDiamondsDisplay();
                });
                
                // Wyczyść ładunek, diamenty są "w locie"
                wz.carried = 0;
            } else {
                // Jeśli nie ma co rozładować lub brakuje elementów, przejdź od razu dalej
                wz.unloadingTimer = 0;
                wz.state = "idle";
            }
          }
          break;
        case "unloading":
          // Odejmuj czas od timera
          if (wz.unloadingTimer > 0) {
            wz.unloadingTimer -= dt;
          }
          
          // Gdy timer dobiegnie końca, przejdź do stanu bezczynności
          if (wz.unloadingTimer <= 0) {
            wz.state = "idle";
            saveGame();
          }
          break;
      }
    }
  }

  function getRandomDiamonds() {
    return Math.floor(Math.random() * (100000 - 100 + 1)) + 100;
  }

  async function init() {
    await loadGraConfig();
    await loadWindziarze();
    await loadNames();
    heroesData = await loadJSON("heroes.json", defaultHeroesData);
    toolsData = await loadJSON("items.json", defaultToolsData);

    const savedState = localStorage.getItem("diamondMineGameState");
    if (savedState) {
      try {
        const state = JSON.parse(savedState);
        playerDiamonds = state.playerDiamonds ?? 0;
        for (let i = 0; i < maxTeamSize; i++) {
          team[i] = state.team[i] ? { ...state.team[i] } : null;
          // Uzupełnij brakujące instanceName po wczytaniu starego zapisu
          if (team[i] && !team[i].instanceName) {
            team[i].instanceName = generateHeroName();
          }
          if (state.corridors && state.corridors[i]) {
            const sc = state.corridors[i];
            corridors[i] = {
              wallHP: sc.wallHP ?? (10000 + Math.floor(Math.random() * 90000)),
              maxDiamonds: sc.maxDiamonds ?? getRandomDiamonds(),
              remainingDiamonds: (typeof sc.remainingDiamonds === 'number') ? sc.remainingDiamonds : (sc.maxDiamonds ?? getRandomDiamonds()),
              wallStart: sc.wallStart ?? 0.1,
              bucketCapacity: sc.bucketCapacity ?? 100,
              bucketAmount: (typeof sc.bucketAmount === 'number') ? sc.bucketAmount : 0
            };
          } else {
            corridors[i] = { wallHP: 10000 + Math.floor(Math.random() * 90000), maxDiamonds: getRandomDiamonds(), remainingDiamonds: getRandomDiamonds(), wallStart: 0.1, bucketCapacity: 100, bucketAmount: 0 };
          }
        }
        equippedTools = state.equippedTools || [];
        windziarzTeam = (state.windziarzTeam || []).map(w => ({ ...w }));
        windziarzPurchased = !!state.windziarzPurchased;
        updateMiningBoost();
      } catch {
        localStorage.removeItem("diamondMineGameState");
      }
    } else {
      // Nowa gra: losuj ilość diamentów na start
      for (let i = 0; i < maxTeamSize; i++) {
        corridors[i] = createNewCorridor();
      }
    }
    // Dodaj domyślnego bohatera tylko jeśli nie istnieje
    if (!team.some(h => h)) {
      team[1] = createHeroInstance(heroesData[0]); // Użyj danych z heroes.json
    }
    updateDiamondsDisplay();
    renderTeam();
    renderHeroesShop();
    renderToolsShop();
    checkElevatorEnabled();
    renderWindziarzeShop();
    renderElevator();
    loop();
  }

  let lastTime = performance.now();
  let renderAccum = 0;
  const RENDER_INTERVAL = 0.18; // sekundy (ok. 5-6 FPS dla UI)
  function loop() {
    const now = performance.now();
    const delta = (now - lastTime) / 1000;
    lastTime = now;
    gameLoopStep(delta);
    windziarzGameLoop(delta);
    renderAccum += delta;
    if (renderAccum >= RENDER_INTERVAL) {
      const sx = window.scrollX, sy = window.scrollY;
      renderTeam();
      if (window.scrollY !== sy || window.scrollX !== sx) window.scrollTo(sx, sy);
      renderAccum = 0;
    }
    requestAnimationFrame(loop);
  }

  btnReset.onclick = () => {
    localStorage.removeItem("diamondMineGameState");
    location.reload();
  };

  // przycisk ręcznego kopania
  btnMine.onclick = () => {
    const gain = 1;
    playerDiamonds += gain;
    updateDiamondsDisplay();
    saveGame();
    try {
      const startRect = btnMine.getBoundingClientRect();
      const endRect = playerDiamondsSpan.getBoundingClientRect();
      spawnDiamondSprites(startRect, endRect, 1, 400);
    } catch {}
  };

  window.addEventListener('resize', () => {
    renderElevator();
  });

  init();

})();
</script>
</body>
</html>
